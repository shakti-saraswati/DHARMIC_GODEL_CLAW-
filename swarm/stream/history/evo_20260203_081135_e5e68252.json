{
  "id": "evo_20260203_081135_e5e68252",
  "timestamp": "2026-02-03T08:11:35.629391",
  "state": "write",
  "agent": "writer",
  "action": "implementation_complete",
  "parent_id": "evo_20260203_081028_681efac9",
  "fitness": null,
  "files_changed": [
    "swarm/communication/shared_context.py",
    "swarm/communication/message_types.py",
    "swarm/communication/__init__.py"
  ],
  "metadata": {
    "files": [
      {
        "path": "swarm/communication/shared_context.py",
        "action": "create",
        "content": "\"\"\"\nShared context system for agent communication with thread-safe operations.\n\"\"\"\n\nimport threading\nfrom typing import Any, Dict, Optional, Set, Callable, List\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport json\nimport copy\n\n\n@dataclass\nclass ContextEntry:\n    \"\"\"Single context entry with metadata.\"\"\"\n    value: Any\n    timestamp: datetime = field(default_factory=datetime.now)\n    agent_id: Optional[str] = None\n    version: int = 1\n\n\nclass SharedContext:\n    \"\"\"Thread-safe shared context for agent communication.\"\"\"\n    \n    def __init__(self) -> None:\n        self._data: Dict[str, ContextEntry] = {}\n        self._lock = threading.RLock()\n        self._subscribers: Dict[str, Set[Callable[[str, Any], None]]] = {}\n        self._access_log: List[Dict[str, Any]] = []\n    \n    def set(self, key: str, value: Any, agent_id: Optional[str] = None) -> None:\n        \"\"\"Set a context value with optional agent tracking.\"\"\"\n        with self._lock:\n            old_entry = self._data.get(key)\n            version = (old_entry.version + 1) if old_entry else 1\n            \n            self._data[key] = ContextEntry(\n                value=value,\n                timestamp=datetime.now(),\n                agent_id=agent_id,\n                version=version\n            )\n            \n            self._log_access(\"set\", key, agent_id)\n            self._notify_subscribers(key, value)\n    \n    def get(self, key: str, default: Any = None, agent_id: Optional[str] = None) -> Any:\n        \"\"\"Get a context value with optional default.\"\"\"\n        with self._lock:\n            self._log_access(\"get\", key, agent_id)\n            entry = self._data.get(key)\n            return entry.value if entry else default\n    \n    def get_with_metadata(self, key: str, agent_id: Optional[str] = None) -> Optional[ContextEntry]:\n        \"\"\"Get context entry with full metadata.\"\"\"\n        with self._lock:\n            self._log_access(\"get_metadata\", key, agent_id)\n            entry = self._data.get(key)\n            return copy.deepcopy(entry) if entry else None\n    \n    def delete(self, key: str, agent_id: Optional[str] = None) -> bool:\n        \"\"\"Delete a context key. Returns True if key existed.\"\"\"\n        with self._lock:\n            self._log_access(\"delete\", key, agent_id)\n            existed = key in self._data\n            if existed:\n                del self._data[key]\n                self._notify_subscribers(key, None)\n            return existed\n    \n    def keys(self) -> List[str]:\n        \"\"\"Get all context keys.\"\"\"\n        with self._lock:\n            return list(self._data.keys())\n    \n    def update(self, updates: Dict[str, Any], agent_id: Optional[str] = None) -> None:\n        \"\"\"Update multiple keys atomically.\"\"\"\n        with self._lock:\n            for key, value in updates.items():\n                self.set(key, value, agent_id)\n    \n    def subscribe(self, key: str, callback: Callable[[str, Any], None]) -> None:\n        \"\"\"Subscribe to changes on a specific key.\"\"\"\n        with self._lock:\n            if key not in self._subscribers:\n                self._subscribers[key] = set()\n            self._subscribers[key].add(callback)\n    \n    def unsubscribe(self, key: str, callback: Callable[[str, Any], None]) -> None:\n        \"\"\"Unsubscribe from key changes.\"\"\"\n        with self._lock:\n            if key in self._subscribers:\n                self._subscribers[key].discard(callback)\n                if not self._subscribers[key]:\n                    del self._subscribers[key]\n    \n    def get_access_log(self) -> List[Dict[str, Any]]:\n        \"\"\"Get recent access log entries.\"\"\"\n        with self._lock:\n            return copy.deepcopy(self._access_log[-100:])  # Last 100 entries\n    \n    def clear(self, agent_id: Optional[str] = None) -> None:\n        \"\"\"Clear all context data.\"\"\"\n        with self._lock:\n            self._data.clear()\n            self._log_access(\"clear\", \"*\", agent_id)\n    \n    def snapshot(self) -> Dict[str, Any]:\n        \"\"\"Create a snapshot of current context values.\"\"\"\n        with self._lock:\n            return {key: entry.value for key, entry in self._data.items()}\n    \n    def restore_snapshot(self, snapshot: Dict[str, Any], agent_id: Optional[str] = None) -> None:\n        \"\"\"Restore context from a snapshot.\"\"\"\n        with self._lock:\n            self._data.clear()\n            for key, value in snapshot.items():\n                self._data[key] = ContextEntry(\n                    value=value,\n                    timestamp=datetime.now(),\n                    agent_id=agent_id,\n                    version=1\n                )\n            self._log_access(\"restore\", \"*\", agent_id)\n    \n    def _notify_subscribers(self, key: str, value: Any) -> None:\n        \"\"\"Notify subscribers of key changes.\"\"\"\n        if key in self._subscribers:\n            for callback in self._subscribers[key].copy():\n                try:\n                    callback(key, value)\n                except Exception:\n                    # Remove broken callbacks\n                    self._subscribers[key].discard(callback)\n    \n    def _log_access(self, operation: str, key: str, agent_id: Optional[str]) -> None:\n        \"\"\"Log context access for debugging.\"\"\"\n        self._access_log.append({\n            \"operation\": operation,\n            \"key\": key,\n            \"agent_id\": agent_id,\n            \"timestamp\": datetime.now().isoformat()\n        })\n        \n        # Keep log size manageable\n        if len(self._access_log) > 1000:\n            self._access_log = self._access_log[-500:]\n\n\n# Global shared context instance\nglobal_context = SharedContext()"
      },
      {
        "path": "swarm/communication/message_types.py",
        "action": "create",
        "content": "\"\"\"Message type definitions and validation for the swarm communication system.\"\"\"\n\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\nimport json\n\n\nclass MessageType(Enum):\n    \"\"\"Enumeration of message types in the swarm.\"\"\"\n    \n    PROPOSAL = \"proposal\"\n    APPROVAL = \"approval\"\n    REJECTION = \"rejection\"\n    IMPLEMENTATION = \"implementation\"\n    STATUS_UPDATE = \"status_update\"\n    ERROR = \"error\"\n    HEARTBEAT = \"heartbeat\"\n    TASK_REQUEST = \"task_request\"\n    TASK_RESPONSE = \"task_response\"\n\n\nclass Priority(Enum):\n    \"\"\"Message priority levels.\"\"\"\n    \n    LOW = 1\n    NORMAL = 2\n    HIGH = 3\n    CRITICAL = 4\n\n\n@dataclass\nclass Message:\n    \"\"\"Base message structure for swarm communication.\"\"\"\n    \n    id: str\n    type: MessageType\n    sender: str\n    recipient: Optional[str]\n    content: Dict[str, Any]\n    priority: Priority = Priority.NORMAL\n    timestamp: Optional[datetime] = None\n    parent_id: Optional[str] = None\n    \n    def __post_init__(self) -> None:\n        \"\"\"Set timestamp if not provided.\"\"\"\n        if self.timestamp is None:\n            self.timestamp = datetime.utcnow()\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert message to dictionary for serialization.\"\"\"\n        return {\n            'id': self.id,\n            'type': self.type.value,\n            'sender': self.sender,\n            'recipient': self.recipient,\n            'content': self.content,\n            'priority': self.priority.value,\n            'timestamp': self.timestamp.isoformat() if self.timestamp else None,\n            'parent_id': self.parent_id\n        }\n    \n    def to_json(self) -> str:\n        \"\"\"Convert message to JSON string.\"\"\"\n        return json.dumps(self.to_dict())\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Message':\n        \"\"\"Create message from dictionary.\"\"\"\n        timestamp = None\n        if data.get('timestamp'):\n            timestamp = datetime.fromisoformat(data['timestamp'])\n        \n        return cls(\n            id=data['id'],\n            type=MessageType(data['type']),\n            sender=data['sender'],\n            recipient=data.get('recipient'),\n            content=data['content'],\n            priority=Priority(data.get('priority', Priority.NORMAL.value)),\n            timestamp=timestamp,\n            parent_id=data.get('parent_id')\n        )\n    \n    @classmethod\n    def from_json(cls, json_str: str) -> 'Message':\n        \"\"\"Create message from JSON string.\"\"\"\n        try:\n            data = json.loads(json_str)\n            return cls.from_dict(data)\n        except (json.JSONDecodeError, KeyError, ValueError) as e:\n            raise MessageValidationError(f\"Invalid message JSON: {e}\")\n\n\n@dataclass\nclass ProposalMessage:\n    \"\"\"Specialized message for proposals.\"\"\"\n    \n    title: str\n    description: str\n    changes: List[str]\n    rationale: str\n    risk_level: str = \"low\"\n    estimated_effort: str = \"small\"\n    \n    def to_message(self, sender: str, message_id: str) -> Message:\n        \"\"\"Convert to base Message.\"\"\"\n        return Message(\n            id=message_id,\n            type=MessageType.PROPOSAL,\n            sender=sender,\n            recipient=None,\n            content={\n                'title': self.title,\n                'description': self.description,\n                'changes': self.changes,\n                'rationale': self.rationale,\n                'risk_level': self.risk_level,\n                'estimated_effort': self.estimated_effort\n            },\n            priority=Priority.NORMAL\n        )\n\n\n@dataclass\nclass ApprovalMessage:\n    \"\"\"Specialized message for approvals.\"\"\"\n    \n    proposal_id: str\n    approved: bool\n    feedback: str = \"\"\n    conditions: List[str] = None\n    \n    def __post_init__(self) -> None:\n        \"\"\"Initialize conditions if None.\"\"\"\n        if self.conditions is None:\n            self.conditions = []\n    \n    def to_message(self, sender: str, message_id: str) -> Message:\n        \"\"\"Convert to base Message.\"\"\"\n        msg_type = MessageType.APPROVAL if self.approved else MessageType.REJECTION\n        return Message(\n            id=message_id,\n            type=msg_type,\n            sender=sender,\n            recipient=None,\n            content={\n                'proposal_id': self.proposal_id,\n                'approved': self.approved,\n                'feedback': self.feedback,\n                'conditions': self.conditions\n            },\n            parent_id=self.proposal_id,\n            priority=Priority.HIGH\n        )\n\n\n@dataclass\nclass StatusMessage:\n    \"\"\"Specialized message for status updates.\"\"\"\n    \n    status: str\n    details: Dict[str, Any]\n    health: str = \"healthy\"\n    \n    def to_message(self, sender: str, message_id: str) -> Message:\n        \"\"\"Convert to base Message.\"\"\"\n        return Message(\n            id=message_id,\n            type=MessageType.STATUS_UPDATE,\n            sender=sender,\n            recipient=None,\n            content={\n                'status': self.status,\n                'details': self.details,\n                'health': self.health\n            },\n            priority=Priority.LOW\n        )\n\n\nclass MessageValidationError(Exception):\n    \"\"\"Exception raised for message validation errors.\"\"\"\n    pass\n\n\ndef validate_message(message: Message) -> bool:\n    \"\"\"Validate message structure and content.\n    \n    Args:\n        message: Message to validate\n        \n    Returns:\n        True if valid\n        \n    Raises:\n        MessageValidationError: If message is invalid\n    \"\"\"\n    if not message.id:\n        raise MessageValidationError(\"Message ID is required\")\n    \n    if not message.sender:\n        raise MessageValidationError(\"Sender is required\")\n    \n    if not isinstance(message.type, MessageType):\n        raise MessageValidationError(\"Invalid message type\")\n    \n    if not isinstance(message.priority, Priority):\n        raise MessageValidationError(\"Invalid priority\")\n    \n    if not isinstance(message.content, dict):\n        raise MessageValidationError(\"Content must be a dictionary\")\n    \n    # Type-specific validation\n    if message.type == MessageType.PROPOSAL:\n        required_fields = ['title', 'description', 'changes', 'rationale']\n        for field in required_fields:\n            if field not in message.content:\n                raise MessageValidationError(f\"Proposal missing required field: {field}\")\n    \n    elif message.type in [MessageType.APPROVAL, MessageType.REJECTION]:\n        if 'proposal_id' not in message.content:\n            raise MessageValidationError(\"Approval/rejection missing proposal_id\")\n        if 'approved' not in message.content:\n            raise MessageValidationError(\"Approval/rejection missing approved field\")\n    \n    return True\n\n\ndef create_heartbeat(sender: str, message_id: str) -> Message:\n    \"\"\"Create a heartbeat message.\n    \n    Args:\n        sender: Agent sending heartbeat\n        message_id: Unique message identifier\n        \n    Returns:\n        Heartbeat message\n    \"\"\"\n    return Message(\n        id=message_id,\n        type=MessageType.HEARTBEAT,\n        sender=sender,\n        recipient=None,\n        content={'timestamp': datetime.utcnow().isoformat()},\n        priority=Priority.LOW\n    )\n\n\ndef create_error_message(sender: str, message_id: str, error: str, \n                        context: Optional[Dict[str, Any]] = None) -> Message:\n    \"\"\"Create an error message.\n    \n    Args:\n        sender: Agent reporting error\n        message_id: Unique message identifier\n        error: Error description\n        context: Additional error context\n        \n    Returns:\n        Error message\n    \"\"\"\n    content = {'error': error}\n    if context:\n        content['context'] = context\n    \n    return Message(\n        id=message_id,\n        type=MessageType.ERROR,\n        sender=sender,\n        recipient=None,\n        content=content,\n        priority=Priority.HIGH\n    )"
      },
      {
        "path": "swarm/communication/__init__.py",
        "action": "create",
        "content": "\"\"\"\nCommunication module for the DHARMIC GODEL CLAW agent swarm.\n\nThis module handles inter-agent communication, message routing, and event broadcasting\nwithin the swarm architecture.\n\"\"\"\n\nfrom typing import Dict, Any, List, Optional, Protocol, runtime_checkable\nimport logging\n\nfrom .message_bus import MessageBus, Message, MessageType\nfrom .event_system import EventSystem, Event, EventHandler\nfrom .protocol import CommunicationProtocol, AgentMessage\n\n__version__ = \"0.1.0\"\n__all__ = [\n    \"MessageBus\",\n    \"Message\", \n    \"MessageType\",\n    \"EventSystem\",\n    \"Event\",\n    \"EventHandler\",\n    \"CommunicationProtocol\",\n    \"AgentMessage\",\n    \"get_message_bus\",\n    \"get_event_system\",\n]\n\n# Module-level instances\n_message_bus: Optional[MessageBus] = None\n_event_system: Optional[EventSystem] = None\n\nlogger = logging.getLogger(__name__)\n\n\ndef get_message_bus() -> MessageBus:\n    \"\"\"\n    Get the singleton MessageBus instance.\n    \n    Returns:\n        MessageBus: The global message bus instance\n        \n    Raises:\n        RuntimeError: If message bus is not initialized\n    \"\"\"\n    global _message_bus\n    if _message_bus is None:\n        _message_bus = MessageBus()\n        logger.info(\"Initialized global message bus\")\n    return _message_bus\n\n\ndef get_event_system() -> EventSystem:\n    \"\"\"\n    Get the singleton EventSystem instance.\n    \n    Returns:\n        EventSystem: The global event system instance\n        \n    Raises:\n        RuntimeError: If event system is not initialized\n    \"\"\"\n    global _event_system\n    if _event_system is None:\n        _event_system = EventSystem()\n        logger.info(\"Initialized global event system\")\n    return _event_system\n\n\ndef initialize_communication(config: Optional[Dict[str, Any]] = None) -> None:\n    \"\"\"\n    Initialize the communication subsystem with optional configuration.\n    \n    Args:\n        config: Optional configuration dictionary\n        \n    Raises:\n        ValueError: If configuration is invalid\n    \"\"\"\n    try:\n        global _message_bus, _event_system\n        \n        if config is None:\n            config = {}\n            \n        # Initialize message bus\n        _message_bus = MessageBus(config.get(\"message_bus\", {}))\n        \n        # Initialize event system  \n        _event_system = EventSystem(config.get(\"event_system\", {}))\n        \n        logger.info(\"Communication subsystem initialized successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Failed to initialize communication subsystem: {e}\")\n        raise\n\n\ndef shutdown_communication() -> None:\n    \"\"\"\n    Shutdown the communication subsystem and cleanup resources.\n    \"\"\"\n    global _message_bus, _event_system\n    \n    try:\n        if _message_bus is not None:\n            _message_bus.shutdown()\n            _message_bus = None\n            \n        if _event_system is not None:\n            _event_system.shutdown()\n            _event_system = None\n            \n        logger.info(\"Communication subsystem shutdown complete\")\n        \n    except Exception as e:\n        logger.error(f\"Error during communication shutdown: {e}\")\n        raise"
      }
    ]
  }
}